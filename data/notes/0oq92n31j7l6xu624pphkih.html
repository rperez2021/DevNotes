<h1 id="promises"><a aria-hidden="true" class="anchor-heading" href="#promises"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promises</h1>
<h2 id="general-info"><a aria-hidden="true" class="anchor-heading" href="#general-info"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>General Info</h2>
<p>Promises are a mechanism of handling asynchronous code, and they’re one you will see somewhat often when using other libraries or frameworks. Knowing what they are and how to use them is quite useful.</p>
<p>A promise has 3 states:</p>
<ul>
<li><strong>Pending</strong>: You don’t know if you will get that phone</li>
<li><strong>Fulfilled</strong>: Mom is happy, she buys you a brand new phone</li>
<li><strong>Rejected</strong>: Mom is unhappy, she doesn’t buy you a phone</li>
</ul>
<h3 id="async-await"><a aria-hidden="true" class="anchor-heading" href="#async-await"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Async Await</h3>
<p>ES7 introduced async and await syntax. It makes the asynchronous syntax easier to understand, without the <code>.then()</code> and <code>.catch()</code>.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">askMom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'before asking Mom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> phone <span class="token operator">=</span> <span class="token keyword control-flow">await</span> willIGetNewPhone<span class="token punctuation">;</span>
        <span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">showOff</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'after asking mom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span><span class="token property-access">message</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// async await it here too</span>
<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">await</span> <span class="token function">askMom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="from-you-dont-know-js"><a aria-hidden="true" class="anchor-heading" href="#from-you-dont-know-js"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>From You Dont Know JS</h2>
<p>Note: Because a Promise is externally immutable once resolved, it's now safe to pass that value around to any party and know that it cannot be modified accidentally or maliciously. This is especially true in relation to multiple parties observing the resolution of a Promise. It is not possible for one party to affect another party's ability to observe Promise resolution. Immutability may sound like an academic topic, but it's actually one of the most fundamental and important aspects of Promise design, and shouldn't be casually passed over.</p>
<p>The new Promise() constructor should only be used for legacy async tasks, like usage of <code>setTimeout</code> or <code>XMLHttpRequest</code>. A new Promise is created with the new keyword and the promise provides resolve and reject functions to the provided callback:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Do an async task async task and then...</span>

    <span class="token keyword control-flow">if</span><span class="token punctuation">(</span><span class="token comment">/* good condition */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Success!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Failure!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">/* do something with the result */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* error :( */</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword control-flow">finally</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">/* executes regardless or success for failure */</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>It's up to the developer to manually call resolve or reject within the body of the callback based on the result of their given task. A realistic example would be converting XMLHttpRequest to a promise-based task:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// From Jake Archibald's Promises and Back:</span>
<span class="token comment">// http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promisifying-xmlhttprequest</span>

<span class="token keyword">function</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Return a new promise.</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Do the usual XHR stuff</span>
    <span class="token keyword">var</span> req <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    req<span class="token punctuation">.</span><span class="token method function property-access">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>

    req<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// This is called even on 404 etc</span>
      <span class="token comment">// so check the status</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token property-access">status</span> <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Resolve the promise with the response text</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token property-access">response</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// Otherwise reject with the status text</span>
        <span class="token comment">// which will hopefully be a meaningful error</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Error</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token property-access">statusText</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// Handle network errors</span>
    req<span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Network Error"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// Make the request</span>
    req<span class="token punctuation">.</span><span class="token method function property-access">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Use it!</span>
<span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'story.json'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"Success!"</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span><span class="token string">"Failed!"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Sometimes you don't need to complete an async tasks within the promise -- if it's possible that an async action will be taken, however, returning a promise will be best so that you can always count on a promise coming out of a given function. In that case you can simply call <code>Promise.resolve()</code> or <code>Promise.reject()</code> without using the new keyword. For example:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> userCache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">getUserDetail</span><span class="token punctuation">(</span><span class="token parameter">username</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// In both cases, cached or not, a promise will be returned</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>userCache<span class="token punctuation">[</span>username<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Return a promise without the "new" keyword</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span>userCache<span class="token punctuation">[</span>username<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Use the fetch API to get the information</span>
  <span class="token comment">// fetch returns a promise</span>
  <span class="token keyword control-flow">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'users/'</span> <span class="token operator">+</span> username <span class="token operator">+</span> <span class="token string">'.json'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      userCache<span class="token punctuation">[</span>username<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>
      <span class="token keyword control-flow">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword control-flow">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Could not find user: '</span> <span class="token operator">+</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="then"><a aria-hidden="true" class="anchor-heading" href="#then"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>then()</h3>
<p>All promise instances get a then method which allows you to react to the promise.  The first then method callback receives the result given to it by the resolve() call:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// A mock async action using setTimeout</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// From the console:</span>
<span class="token comment">// 10</span>
</code></pre>
<p>The then callback is triggered when the promise is resolved.  You can also chain then method callbacks:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// A mock async action using setTimeout</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'first then: '</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword control-flow">return</span> num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'second then: '</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword control-flow">return</span> num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'last then: '</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// From the console:</span>
<span class="token comment">// first then:  10</span>
<span class="token comment">// second then:  20</span>
<span class="token comment">// last then:  40</span>
</code></pre>
<h3 id="catch"><a aria-hidden="true" class="anchor-heading" href="#catch"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>catch()</h3>
<p>The catch callback is executed when the promise is rejected:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// A mock async action using setTimeout</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Done!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'catch: '</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// From the console:</span>
<span class="token comment">// 'catch: Done!'</span>
</code></pre>
<h3 id="finally"><a aria-hidden="true" class="anchor-heading" href="#finally"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>finally()</h3>
<p>The newly introduced finally callback is called regardless of success or failure:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"Nope"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token keyword control-flow">finally</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"finally"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// >> fail</span>
<span class="token comment">// >> finally</span>
</code></pre>
<h3 id="promiseall"><a aria-hidden="true" class="anchor-heading" href="#promiseall"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise.all</h3>
<p>Think about JavaScript loaders:  there are times when you trigger multiple async interactions but only want to respond when all of them are completed -- that's where Promise.all comes in.  The Promise.all method takes an array of promises and fires one callback once they are all resolved:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">results</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Both promises resolved</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// One or more promises was rejected</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>A perfect way of thinking about Promise.all is firing off multiple AJAX (via fetch) requests at one time:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> request1 <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/users.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> request2 <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/articles.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>request1<span class="token punctuation">,</span> request2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">results</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Both promises done!</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>You could combine APIs like fetch and the Battery API since they both return promises:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/users.json'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token dom variable">navigator</span><span class="token punctuation">.</span><span class="token method function property-access">getBattery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">results</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Both promises done!</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Dealing with rejection is, of course, hard. If any promise is rejected the catch fires for the first rejection:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> req1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// A mock async action using setTimeout</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'First!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> req2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// A mock async action using setTimeout</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Second!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>req1<span class="token punctuation">,</span> req2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">results</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Then: '</span><span class="token punctuation">,</span> results<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Catch: '</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// From the console:</span>
<span class="token comment">// Catch: Second!</span>
</code></pre>
<h3 id="promiserace"><a aria-hidden="true" class="anchor-heading" href="#promiserace"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise.race()</h3>
<p>Promise.race is an interesting function -- instead of waiting for all promises to be resolved or rejected, Promise.race triggers as soon as any promise in the array is resolved or rejected:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> req1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// A mock async action using setTimeout</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'First!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> req2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// A mock async action using setTimeout</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Second!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>req1<span class="token punctuation">,</span> req2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">one</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Then: '</span><span class="token punctuation">,</span> one<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">one<span class="token punctuation">,</span> two</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">'Catch: '</span><span class="token punctuation">,</span> one<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// From the console:</span>
<span class="token comment">// Then: Second!</span>
</code></pre>
<p>A use case could be triggering a request to a primary source and a secondary source (in case the primary or secondary are unavailable).</p>
<h3 id="completion-event"><a aria-hidden="true" class="anchor-heading" href="#completion-event"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Completion Event</h3>
<p>Whether you call it a "completion event" or a "continuation event" depends on your perspective. Is the focus more on what happens with foo(..), or what happens after <code>foo(..)</code> finishes? Both perspectives are accurate and useful. The event notification tells us that <code>foo(..)</code> has completed, but also that it's OK to continue with the next step. Indeed, the callback you pass to be called for the event notification is itself what we've previously called a continuation. Because completion event is a bit more focused on the foo(..), which more has our attention at present, we slightly favor completion event for the rest of this text.</p>
<p>The pattern shown with <code>new Promise( function(..){ .. } )</code> is generally called the "revealing constructor". The function passed in is executed immediately (not async deferred, as callbacks to then(..) are), and it's provided two parameters, which in this case we've named resolve and reject. These are the resolution functions for the promise. resolve(..) generally signals fulfillment, and <code>reject(..)</code> signals rejection.</p>
<h3 id="thenable-duck-typing"><a aria-hidden="true" class="anchor-heading" href="#thenable-duck-typing"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Thenable Duck Typing</h3>
<p>An important detail is how to know for sure if some value is a genuine Promise or not. Or more directly, is it a value that will behave like a Promise?</p>
<p>Given that Promises are constructed by the new Promise(..) syntax, you might think that p instanceof Promise would be an acceptable check. But unfortunately, there are a number of reasons that's not totally sufficient.</p>
<p>Mainly, you can receive a Promise value from another browser window (iframe, etc.), which would have its own Promise different from the one in the current window/frame, and that check would fail to identify the Promise instance.</p>
<p>As such, it was decided that the way to recognize a Promise (or something that behaves like a Promise) would be to define something called a "thenable" as any object or function which has a then(..) method on it. It is assumed that any such value is a Promise-conforming thenable.</p>
<p>The standards decision to hijack the previously nonreserved -- and completely general-purpose sounding -- then property name means that no value (or any of its delegates), either past, present, or future, can have a then(..) function present, either on purpose or by accident, or that value will be confused for a thenable in Promises systems, which will probably create bugs that are really hard to track down.</p>
<p><em>Warning</em>: I do not like how we ended up with duck typing of thenables for Promise recognition. There were other options, such as "branding" or even "anti-branding"; what we got seems like a worst-case compromise. But it's not all doom and gloom. Thenable duck typing can be helpful, as we'll see later. Just beware that thenable duck typing can be hazardous if it incorrectly identifies something as a Promise that isn't.</p>
<h3 id="promise-trust"><a aria-hidden="true" class="anchor-heading" href="#promise-trust"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise Trust</h3>
<p>Whereas the future values and completion events analogies play out explicitly in the code patterns we've explored, it won't be entirely obvious why or how Promises are designed to solve all of the inversion of control trust issues we laid out in the "Trust Issues" section of Chapter 2. But with a little digging, we can uncover some important guarantees that restore the confidence in async coding that Chapter 2 tore down!</p>
<p>Let's start by reviewing the trust issues with callbacks-only coding. When you pass a callback to a utility foo(..), it might:</p>
<ul>
<li>Call the callback too early</li>
<li>Call the callback too late (or never)</li>
<li>Call the callback too few or too many times</li>
<li>Fail to pass along any necessary environment/parameters</li>
<li>Swallow any errors/exceptions that may happen</li>
</ul>
<p>The characteristics of Promises are intentionally designed to provide useful, repeatable answers to all these concerns.</p>
<h4 id="calling-too-early"><a aria-hidden="true" class="anchor-heading" href="#calling-too-early"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Calling Too Early</h4>
<p>Primarily, this is a concern of whether code can introduce Zalgo-like effects (see Chapter 2), where sometimes a task finishes synchronously and sometimes asynchronously, which can lead to race conditions.</p>
<p>Promises by definition cannot be susceptible to this concern, because even an immediately fulfilled Promise (like new Promise(function(resolve){ resolve(42); })) cannot be observed synchronously.</p>
<p>That is, when you call then(..) on a Promise, even if that Promise was already resolved, the callback you provide to then(..) will always be called asynchronously (for more on this, refer back to "Jobs" in Chapter 1).</p>
<p>No more need to insert your own setTimeout(..,0) hacks. Promises prevent Zalgo automatically.</p>
<h4 id="calling-too-late"><a aria-hidden="true" class="anchor-heading" href="#calling-too-late"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Calling Too Late</h4>
<p>Similar to the previous point, a Promise's then(..) registered observation callbacks are automatically scheduled when either resolve(..) or reject(..) are called by the Promise creation capability. Those scheduled callbacks will predictably be fired at the next asynchronous moment (see "Jobs" in Chapter 1).</p>
<p>It's not possible for synchronous observation, so it's not possible for a synchronous chain of tasks to run in such a way to in effect "delay" another callback from happening as expected. That is, when a Promise is resolved, all then(..) registered callbacks on it will be called, in order, immediately at the next asynchronous opportunity (again, see "Jobs" in Chapter 1), and nothing that happens inside of one of those callbacks can affect/delay the calling of the other callbacks.</p>
<h4 id="promise-scheduling-quirks"><a aria-hidden="true" class="anchor-heading" href="#promise-scheduling-quirks"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise Scheduling Quirks</h4>
<p>It's important to note, though, that there are lots of nuances of scheduling where the relative ordering between callbacks chained off two separate Promises is not reliably predictable.</p>
<p>If two promises p1 and p2 are both already resolved, it should be true that p1.then(..); p2.then(..) would end up calling the callback(s) for p1 before the ones for p2. But there are subtle cases where that might not be true, such as the following:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span> <span class="token string">"B"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span> p3 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span> <span class="token string">"A"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p1<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p2<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// A B  &#x3C;-- not  B A  as you might expect</span>
</code></pre>
<p>We'll cover this more later, but as you can see, p1 is resolved not with an immediate value, but with another promise p3 which is itself resolved with the value "B". The specified behavior is to unwrap p3 into p1, but asynchronously, so p1's callback(s) are behind p2's callback(s) in the asynchronous Job queue</p>
<p>To avoid such nuanced nightmares, you should never rely on anything about the ordering/scheduling of callbacks across Promises. In fact, a good practice is not to code in such a way where the ordering of multiple callbacks matters at all. Avoid that if you can.</p>
<h4 id="never-calling-the-callback"><a aria-hidden="true" class="anchor-heading" href="#never-calling-the-callback"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Never Calling the Callback</h4>
<p>This is a very common concern. It's addressable in several ways with Promises.</p>
<p>First, nothing (not even a JS error) can prevent a Promise from notifying you of its resolution (if it's resolved). If you register both fulfillment and rejection callbacks for a Promise, and the Promise gets resolved, one of the two callbacks will always be called.</p>
<p>Of course, if your callbacks themselves have JS errors, you may not see the outcome you expect, but the callback will in fact have been called. We'll cover later how to be notified of an error in your callback, because even those don't get swallowed.</p>
<p>But what if the Promise itself never gets resolved either way? Even that is a condition that Promises provide an answer for, using a higher level abstraction called a "race":</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// a utility for timing out a Promise</span>
<span class="token keyword">function</span> <span class="token function">timeoutPromise</span><span class="token punctuation">(</span><span class="token parameter">delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span> <span class="token string">"Timeout!"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// setup a timeout for `foo()`</span>
<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">race</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// attempt `foo()`</span>
  <span class="token function">timeoutPromise</span><span class="token punctuation">(</span> <span class="token number">3000</span> <span class="token punctuation">)</span>  <span class="token comment">// give it 3 seconds</span>
<span class="token punctuation">]</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// `foo(..)` fulfilled in time!</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// either `foo()` rejected, or it just</span>
    <span class="token comment">// didn't finish in time, so inspect</span>
    <span class="token comment">// `err` to know which</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>There are more details to consider with this Promise timeout pattern, but we'll come back to it later.</p>
<p>Importantly, we can ensure a signal as to the outcome of foo(), to prevent it from hanging our program indefinitely.</p>
<h4 id="calling-too-few-or-too-many-times"><a aria-hidden="true" class="anchor-heading" href="#calling-too-few-or-too-many-times"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Calling Too Few or Too Many Times</h4>
<p>By definition, one is the appropriate number of times for the callback to be called. The "too few" case would be zero calls, which is the same as the "never" case we just examined.</p>
<p>The "too many" case is easy to explain. Promises are defined so that they can only be resolved once. If for some reason the Promise creation code tries to call resolve(..) or reject(..) multiple times, or tries to call both, the Promise will accept only the first resolution, and will silently ignore any subsequent attempts.</p>
<p>Because a Promise can only be resolved once, any then(..) registered callbacks will only ever be called once (each).</p>
<p>Of course, if you register the same callback more than once, (e.g., p.then(f); p.then(f);), it'll be called as many times as it was registered. The guarantee that a response function is called only once does not prevent you from shooting yourself in the foot.</p>
<h4 id="failing-to-pass-along-any-parametersenvironment"><a aria-hidden="true" class="anchor-heading" href="#failing-to-pass-along-any-parametersenvironment"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Failing to Pass Along Any Parameters/Environment</h4>
<p>Promises can have, at most, one resolution value (fulfillment or rejection).</p>
<p>If you don't explicitly resolve with a value either way, the value is undefined, as is typical in JS. But whatever the value, it will always be passed to all registered (and appropriate: fulfillment or rejection) callbacks, either now or in the future.</p>
<p>Something to be aware of: If you call <code>resolve(..)</code> or <code>reject(..)</code> with multiple parameters, all subsequent parameters beyond the first will be silently ignored. Although that might seem a violation of the guarantee we just described, it's not exactly, because it constitutes an invalid usage of the Promise mechanism. Other invalid usages of the API (such as calling <code>resolve(..)</code> multiple times) are similarly protected, so the Promise behavior here is consistent (if not a tiny bit frustrating).</p>
<p>If you want to pass along multiple values, you must wrap them in another single value that you pass, such as an array or an object.</p>
<p>As for environment, functions in JS always retain their closure of the scope in which they're defined (see the Scope &#x26; Closures title of this series), so they of course would continue to have access to whatever surrounding state you provide. Of course, the same is true of callbacks-only design, so this isn't a specific augmentation of benefit from Promises -- but it's a guarantee we can rely on nonetheless.</p>
<h4 id="swallowing-any-errorsexceptions"><a aria-hidden="true" class="anchor-heading" href="#swallowing-any-errorsexceptions"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Swallowing Any Errors/Exceptions</h4>
<p>In the base sense, this is a restatement of the previous point. If you reject a Promise with a reason (aka error message), that value is passed to the rejection callback(s).</p>
<p>But there's something much bigger at play here. If at any point in the creation of a Promise, or in the observation of its resolution, a JS exception error occurs, such as a TypeError or ReferenceError, that exception will be caught, and it will force the Promise in question to become rejected.</p>
<p>For example:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  foo<span class="token punctuation">.</span><span class="token method function property-access">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// `foo` is not defined, so error!</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// never gets here :(</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// never gets here :(</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// `err` will be a `TypeError` exception object</span>
    <span class="token comment">// from the `foo.bar()` line.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The JS exception that occurs from <code>foo.bar()</code> becomes a Promise rejection that you can catch and respond to.</p>
<p>This is an important detail, because it effectively solves another potential Zalgo moment, which is that errors could create a synchronous reaction whereas nonerrors would be asynchronous. Promises turn even JS exceptions into asynchronous behavior, thereby reducing the race condition chances greatly.</p>
<p>But what happens if a Promise is fulfilled, but there's a JS exception error during the observation (in a <code>then(..)</code> registered callback)? Even those aren't lost, but you may find how they're handled a bit surprising, until you dig in a little deeper:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    foo<span class="token punctuation">.</span><span class="token method function property-access">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> msg <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// never gets here :(</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// never gets here either :(</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Wait, that makes it seem like the exception from <code>foo.bar()</code> really did get swallowed. Never fear, it didn't. But something deeper is wrong, which is that we've failed to listen for it. The <code>p.then(..)</code> call itself returns another promise, and it's that promise that will be rejected with the TypeError exception.</p>
<p>Why couldn't it just call the error handler we have defined there? Seems like a logical behavior on the surface. <strong>But it would violate the fundamental principle that Promises are immutable once resolved. p was already fulfilled to the value 42, so it can't later be changed to a rejection just because there's an error in observing p's resolution.</strong></p>
<p>Besides the principle violation, such behavior could wreak havoc, if say there were multiple <code>then(..)</code> registered callbacks on the promise p, because some would get called and others wouldn't, and it would be very opaque as to why.</p>
<h4 id="trustable-promise"><a aria-hidden="true" class="anchor-heading" href="#trustable-promise"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Trustable Promise?</h4>
<p>There's one last detail to examine to establish trust based on the Promise pattern.</p>
<p>You've no doubt noticed that Promises don't get rid of callbacks at all. They just change where the callback is passed to. Instead of passing a callback to <code>foo(..)</code>, we get something (ostensibly a genuine Promise) back from <code>foo(..)</code>, and we pass the callback to that something instead.</p>
<p>But why would this be any more trustable than just callbacks alone? How can we be sure the something we get back is in fact a trustable Promise? Isn't it basically all just a house of cards where we can trust only because we already trusted?</p>
<p>One of the most important, but often overlooked, details of Promises is that they have a solution to this issue as well. Included with the native ES6 Promise implementation is <code>Promise.resolve(..)</code>.</p>
<p>If you pass an immediate, non-Promise, non-thenable value to <code>Promise.resolve(..)</code>, you get a promise that's fulfilled with that value. In other words, these two promises p1 and p2 will behave basically identically:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>But if you pass a genuine Promise to <code>Promise.resolve(..)</code>, you just get the same promise back:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> p1 <span class="token punctuation">)</span><span class="token punctuation">;</span>

p1 <span class="token operator">===</span> p2<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre>
<p>Even more importantly, if you pass a non-Promise thenable value to <code>Promise.resolve(..)</code>, it will attempt to unwrap that value, and the unwrapping will keep going until a concrete final non-Promise-like value is extracted.</p>
<p>Recall our previous discussion of thenables?</p>
<p>Consider:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">cb</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// this works OK, but only by good fortune</span>
p
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> val <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// never gets here</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>This p is a thenable, but it's not a genuine Promise. Luckily, it's reasonable, as most will be. But what if you got back instead something that looked like:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">cb<span class="token punctuation">,</span>errcb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">cb</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">errcb</span><span class="token punctuation">(</span> <span class="token string">"evil laugh"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

p
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> val <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// oops, shouldn't have run</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// evil laugh</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>This p is a thenable but it's not so well behaved of a promise. Is it malicious? Or is it just ignorant of how Promises should work? It doesn't really matter, to be honest. In either case, it's not trustable as is.</p>
<p>Nonetheless, we can pass either of these versions of p to <code>Promise.resolve(..)</code>, and we'll get the normalized, safe result we'd expect:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> p <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> val <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// never gets here</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><code>Promise.resolve(..)</code> will accept any thenable, and will unwrap it to its non-thenable value. But you get back from <code>Promise.resolve(..)</code> a real, genuine Promise in its place, one that you can trust. If what you passed in is already a genuine Promise, you just get it right back, so there's no downside at all to filtering through <code>Promise.resolve(..)</code> to gain trust.</p>
<p>So let's say we're calling a <code>foo(..)</code> utility and we're not sure we can trust its return value to be a well-behaving Promise, but we know it's at least a thenable. <code>Promise.resolve(..)</code> will give us a trustable Promise wrapper to chain off of:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// don't just do this:</span>
<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// instead, do this:</span>
<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Note: Another beneficial side effect of wrapping <code>Promise.resolve(..)</code> around any function's return value (thenable or not) is that it's an easy way to normalize that function call into a well-behaving async task. If <code>foo(42)</code> returns an immediate value sometimes, or a Promise other times, <code>Promise.resolve( foo(42) )</code> makes sure it's always a Promise result. And avoiding Zalgo makes for much better code.</p>
<h3 id="chain-flow"><a aria-hidden="true" class="anchor-heading" href="#chain-flow"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Chain Flow</h3>
<p>We've hinted at this a couple of times already, but Promises are not just a mechanism for a single-step this-then-that sort of operation. That's the building block, of course, but it turns out we can string multiple Promises together to represent a sequence of async steps.</p>
<p>The key to making this work is built on two behaviors intrinsic to Promises:</p>
<ul>
<li>Every time you call <code>then(..)</code> on a Promise, it creates and returns a new Promise, which we can chain with.</li>
<li>Whatever value you return from the <code>then(..)</code> call's fulfillment callback (the first parameter) is automatically set as the fulfillment of the chained Promise (from the first point).</li>
</ul>
<p>Let's first illustrate what that means, and then we'll derive how that helps us create async sequences of flow control. Consider the following:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">21</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p2 <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 21</span>

  <span class="token comment">// fulfill `p2` with value `42`</span>
  <span class="token keyword control-flow">return</span> v <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// chain off `p2`</span>
p2<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>By returning <code>v * 2 (i.e., 42)</code>, we fulfill the p2 promise that the first <code>then(..)</code> call created and returned. When p2's <code>then(..)</code> call runs, it's receiving the fulfillment from the return <code>v * 2</code> statement. Of course, p2.<code>then(..)</code> creates yet another promise, which we could have stored in a p3 variable.</p>
<p>But it's a little annoying to have to create an intermediate variable p2 (or p3, etc.). Thankfully, we can easily just chain these together:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">21</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 21</span>

  <span class="token comment">// fulfill the chained promise with value `42`</span>
  <span class="token keyword control-flow">return</span> v <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token comment">// here's the chained promise</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>So now the first <code>then(..)</code> is the first step in an async sequence, and the second <code>then(..)</code> is the second step. This could keep going for as long as you needed it to extend. Just keep chaining off a previous <code>then(..)</code> with each automatically created Promise.</p>
<p>But there's something missing here. What if we want step 2 to wait for step 1 to do something asynchronous? We're using an immediate return statement, which immediately fulfills the chained promise.</p>
<p>The key to making a Promise sequence truly async capable at every step is to recall how <code>Promise.resolve(..)</code> operates when what you pass to it is a Promise or thenable instead of a final value. <code>Promise.resolve(..)</code> directly returns a received genuine Promise, or it unwraps the value of a received thenable -- and keeps going recursively while it keeps unwrapping thenables.</p>
<p>The same sort of unwrapping happens if you return a thenable or Promise from the fulfillment (or rejection) handler. Consider:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">21</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 21</span>

  <span class="token comment">// create a promise and return it</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// fulfill with value `42`</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span> v <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Even though we wrapped 42 up in a promise that we returned, it still got unwrapped and ended up as the resolution of the chained promise, such that the second <code>then(..)</code> still received 42. If we introduce asynchrony to that wrapping promise, everything still nicely works the same:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">21</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 21</span>

  <span class="token comment">// create a promise to return</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// introduce asynchrony!</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// fulfill with value `42`</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span> v <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// runs after the 100ms delay in the previous step</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>That's incredibly powerful! Now we can construct a sequence of however many async steps we want, and each step can delay the next step (or not!), as necessary.</p>
<p>Of course, the value passing from step to step in these examples is optional. If you don't return an explicit value, an implicit undefined is assumed, and the promises still chain together the same way. <strong>Each Promise resolution is thus just a signal to proceed to the next step.</strong></p>
<p>To further the chain illustration, let's generalize a delay-Promise creation (without resolution messages) into a utility we can reuse for multiple steps:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">time</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span> resolve<span class="token punctuation">,</span> time <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">delay</span><span class="token punctuation">(</span> <span class="token number">100</span> <span class="token punctuation">)</span> <span class="token comment">// step 1</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token constant">STEP2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> <span class="token string">"step 2 (after 100ms)"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token function">delay</span><span class="token punctuation">(</span> <span class="token number">200</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token constant">STEP3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> <span class="token string">"step 3 (after another 200ms)"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token constant">STEP4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> <span class="token string">"step 4 (next Job)"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token function">delay</span><span class="token punctuation">(</span> <span class="token number">50</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token constant">STEP5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> <span class="token string">"step 5 (after another 50ms)"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
</code></pre>
<p>...
Calling delay(200) creates a promise that will fulfill in 200ms, and then we return that from the first then(..) fulfillment callback, which causes the second then(..)'s promise to wait on that 200ms promise.</p>
<p>Note: As described, technically there are two promises in that interchange: the 200ms-delay promise and the chained promise that the second <code>then(..)</code> chains from. But you may find it easier to mentally combine these two promises together, because the Promise mechanism automatically merges their states for you. In that respect, you could think of return delay(200) as creating a promise that replaces the earlier-returned chained promise.</p>
<p>To be honest, though, sequences of delays with no message passing isn't a terribly useful example of Promise flow control. Let's look at a scenario that's a little more practical.</p>
<p>Instead of timers, let's consider making Ajax requests:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// assume an `ajax( {url}, {callback} )` utility</span>

<span class="token comment">// Promise-aware ajax</span>
<span class="token keyword">function</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// the `ajax(..)` callback should be our</span>
  <span class="token comment">// promise's `resolve(..)` function</span>
    <span class="token function">ajax</span><span class="token punctuation">(</span> url<span class="token punctuation">,</span> resolve <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>We first define a <code>request(..)</code> utility that constructs a promise to represent the completion of the <code>ajax(..)</code> call:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.1/"</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.2/?v="</span> <span class="token operator">+</span> response1 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> response2 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Note: Developers commonly encounter situations in which they want to do Promise-aware async flow control with utilities that are not themselves Promise-enabled (like <code>ajax(..)</code> here, which expects a callback). Although the native ES6 Promise mechanism doesn't automatically solve this pattern for us, practically all Promise libraries do. They usually call this process "lifting" or "promisifying" or some variation thereof. We'll come back to this technique later.</p>
<p>Using the Promise-returning <code>request(..)</code>, we create the first step in our chain implicitly by calling it with the first URL, and chain off that returned promise with the first <code>then(..)</code>.</p>
<p>Once response1 comes back, we use that value to construct a second URL, and make a second request(..) call. That second <code>request(..)</code> promise is returned so that the third step in our async flow control waits for that Ajax call to complete. Finally, we print response2 once it returns.</p>
<p>The Promise chain we construct is not only a flow control that expresses a multistep async sequence, but it also acts as a message channel to propagate messages from step to step.</p>
<p>What if something went wrong in one of the steps of the Promise chain? An error/exception is on a per-Promise basis, which means it's possible to catch such an error at any point in the chain, and that catching acts to sort of "reset" the chain back to normal operation at that point:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// step 1:</span>
<span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.1/"</span> <span class="token punctuation">)</span>

<span class="token comment">// step 2:</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 foo<span class="token punctuation">.</span><span class="token method function property-access">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined, error!</span>

 <span class="token comment">// never gets here</span>
 <span class="token keyword control-flow">return</span> <span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.2/?v="</span> <span class="token operator">+</span> response1 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>

<span class="token comment">// step 3:</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
 <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">response2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// never gets here</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// rejection handler to catch the error</span>
  <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// `TypeError` from `foo.bar()` error</span>
    <span class="token keyword control-flow">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token comment">// step 4:</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> msg <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 42</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>When the error occurs in step 2, the rejection handler in step 3 catches it. The return value (42 in this snippet), if any, from that rejection handler fulfills the promise for the next step (4), such that the chain is now back in a fulfillment state.</p>
<p>Note: As we discussed earlier, when returning a promise from a fulfillment handler, it's unwrapped and can delay the next step. That's also true for returning promises from rejection handlers, such that if the <code>return 42</code> in step 3 instead returned a promise, that promise could delay step 4. A thrown exception inside either the fulfillment or rejection handler of a <code>then(..)</code> call causes the next (chained) promise to be immediately rejected with that exception.</p>
<p>If you call <code>then(..)</code> on a promise, and you only pass a fulfillment handler to it, an assumed rejection handler is substituted:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">reject</span><span class="token punctuation">(</span> <span class="token string">"Oops"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p2 <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// never gets here</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// assumed rejection handler, if omitted or</span>
  <span class="token comment">// any other non-function value passed</span>
  <span class="token comment">// function(err) {</span>
  <span class="token comment">//     throw err;</span>
  <span class="token comment">// }</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>As you can see, the assumed rejection handler simply rethrows the error, which ends up forcing p2 (the chained promise) to reject with the same error reason. In essence, this allows the error to continue propagating along a Promise chain until an explicitly defined rejection handler is encountered.</p>
<p>Note: We'll cover more details of error handling with Promises a little later, because there are other nuanced details to be concerned about.</p>
<p>If a proper valid function is not passed as the fulfillment handler parameter to <code>then(..)</code>, there's also a default handler substituted:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token comment">// assumed fulfillment handler, if omitted or</span>
  <span class="token comment">// any other non-function value passed</span>
  <span class="token comment">// function(v) {</span>
  <span class="token comment">//     return v;</span>
  <span class="token comment">// }</span>
  <span class="token keyword null nil">null</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// never gets here</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>As you can see, the default fulfillment handler simply passes whatever value it receives along to the next step (Promise).</p>
<p>Note: The <code>then(null,function(err){ .. })</code> pattern -- only handling rejections (if any) but letting fulfillments pass through -- has a shortcut in the API: <code>catch(function(err){ .. })</code>. We'll cover <code>catch(..)</code> more fully in the next section.</p>
<p>Let's review briefly the intrinsic behaviors of Promises that enable chaining flow control:</p>
<p>A <code>then(..)</code> call against one Promise automatically produces a new Promise to return from the call.
Inside the fulfillment/rejection handlers, if you return a value or an exception is thrown, the new returned (chainable) Promise is resolved accordingly.
If the fulfillment or rejection handler returns a Promise, it is unwrapped, so that whatever its resolution is will become the resolution of the chained Promise returned from the current <code>then(..)</code>.
While chaining flow control is helpful, it's probably most accurate to think of it as a side benefit of how Promises compose (combine) together, rather than the main intent. As we've discussed in detail several times already, Promises normalize asynchrony and encapsulate time-dependent value state, and that is what lets us chain them together in this useful way.</p>
<p>Certainly, the sequential expressiveness of the chain (this-then-this-then-this...) is a big improvement over the tangled mess of callbacks as we identified in Chapter 2. But there's still a fair amount of boilerplate <code>(then(..) and function(){ .. })</code> to wade through. In the next chapter, we'll see a significantly nicer pattern for sequential flow control expressivity, with generators.</p>
<h3 id="error-handling"><a aria-hidden="true" class="anchor-heading" href="#error-handling"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Error Handling</h3>
<p>We've already seen several examples of how Promise rejection -- either intentional through calling <code>reject(..)</code> or accidental through JS exceptions -- allows saner error handling in asynchronous programming. Let's circle back though and be explicit about some of the details that we glossed over.</p>
<p>The most natural form of error handling for most developers is the synchronous <code>try..catch</code> construct. Unfortunately, it's synchronous-only, so it fails to help in async code patterns:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    baz<span class="token punctuation">.</span><span class="token method function property-access">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// later throws global error from `baz.bar()`</span>
<span class="token punctuation">}</span>
<span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// never gets here</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>try..catch</code> would certainly be nice to have, but it doesn't work across async operations. That is, unless there's some additional environmental support, which we'll come back to with generators in Chapter 4.</p>
<p>In callbacks, some standards have emerged for patterned error handling, most notably the "error-first callback" style:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword control-flow">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> x <span class="token operator">=</span> baz<span class="token punctuation">.</span><span class="token method function property-access">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">cb</span><span class="token punctuation">(</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span> x <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// success!</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">cb</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bummer :(</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> val <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Note: The <code>try..catch</code> here works only from the perspective that the <code>baz.bar()</code> call will either succeed or fail immediately, synchronously. If <code>baz.bar()</code> was itself its own async completing function, any async errors inside it would not be catchable.</p>
<p>The callback we pass to <code>foo(..)</code> expects to receive a signal of an error by the reserved first parameter err. If present, error is assumed. If not, success is assumed.</p>
<p>This sort of error handling is technically async capable, but it doesn't compose well at all. Multiple levels of error-first callbacks woven together with these ubiquitous if statement checks inevitably will lead you to the perils of callback hell (see Chapter 2).</p>
<p>So we come back to error handling in Promises, with the rejection handler passed to <code>then(..)</code>. Promises don't use the popular "error-first callback" design style, but instead use "split callbacks" style; there's one callback for fulfillment and one for rejection:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">reject</span><span class="token punctuation">(</span> <span class="token string">"Oops"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// never gets here</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Oops"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>While this pattern of error handling makes fine sense on the surface, the nuances of Promise error handling are often a fair bit more difficult to fully grasp.</p>
<p>Consider:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// numbers don't have string functions,</span>
    <span class="token comment">// so will throw an error</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> msg<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// never gets here</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>If the <code>msg.toLowerCase()</code> legitimately throws an error (it does!), why doesn't our error handler get notified? As we explained earlier, it's because that error handler is for the p promise, which has already been fulfilled with value 42. The p promise is immutable, so the only promise that can be notified of the error is the one returned from <code>p.then(..)</code>, which in this case we don't capture.</p>
<p>That should paint a clear picture of why error handling with Promises is error-prone (pun intended). It's far too easy to have errors swallowed, as this is very rarely what you'd intend.</p>
<p>Warning: If you use the Promise API in an invalid way and an error occurs that prevents proper Promise construction, the result will be an immediately thrown exception, not a rejected Promise. Some examples of incorrect usage that fail Promise construction: <code>new Promise(null)</code>, <code>Promise.all()</code>, <code>Promise.race(42)</code>, and so on. You can't get a rejected Promise if you don't use the Promise API validly enough to actually construct a Promise in the first place!</p>
<h4 id="pit-of-despair"><a aria-hidden="true" class="anchor-heading" href="#pit-of-despair"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Pit of Despair</h4>
<p>Jeff Atwood noted years ago: programming languages are often set up in such a way that by default, developers fall into the <a href="http://blog.codinghorror.com/falling-into-the-pit-of-success/">pit of despair</a> -- where accidents are punished -- and that you have to try harder to get it right. He implored us to instead create a "pit of success," where by default you fall into expected (successful) action, and thus would have to try hard to fail.</p>
<p>Promise error handling is unquestionably "pit of despair" design. By default, it assumes that you want any error to be swallowed by the Promise state, and if you forget to observe that state, the error silently languishes/dies in obscurity -- usually despair.</p>
<p>To avoid losing an error to the silence of a forgotten/discarded Promise, some developers have claimed that a "best practice" for Promise chains is to always end your chain with a final catch(..), like:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// numbers don't have string functions,</span>
    <span class="token comment">// so will throw an error</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> msg<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span> handleErrors <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Because we didn't pass a rejection handler to the then(..), the default handler was substituted, which simply propagates the error to the next promise in the chain. As such, both errors that come into p, and errors that come after p in its resolution (like the msg.toLowerCase() one) will filter down to the final handleErrors(..).</p>
<p>Problem solved, right? Not so fast!</p>
<p>What happens if <code>handleErrors(..)</code> itself also has an error in it? Who catches that? There's still yet another unattended promise: the one <code>catch(..)</code> returns, which we don't capture and don't register a rejection handler for.</p>
<p>You can't just stick another catch(..) on the end of that chain, because it too could fail. The last step in any Promise chain, whatever it is, always has the possibility, even decreasingly so, of dangling with an uncaught error stuck inside an unobserved Promise.</p>
<p>Sound like an impossible conundrum yet?</p>
<h4 id="uncaught-handling"><a aria-hidden="true" class="anchor-heading" href="#uncaught-handling"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Uncaught Handling</h4>
<p>It's not exactly an easy problem to solve completely. There are other ways to approach it which many would say are better.</p>
<p>Some Promise libraries have added methods for registering something like a "global unhandled rejection" handler, which would be called instead of a globally thrown error. But their solution for how to identify an error as "uncaught" is to have an arbitrary-length timer, say 3 seconds, running from time of rejection. If a Promise is rejected but no error handler is registered before the timer fires, then it's assumed that you won't ever be registering a handler, so it's "uncaught."</p>
<p>In practice, this has worked well for many libraries, as most usage patterns don't typically call for significant delay between Promise rejection and observation of that rejection. But this pattern is troublesome because 3 seconds is so arbitrary (even if empirical), and also because there are indeed some cases where you want a Promise to hold on to its rejectedness for some indefinite period of time, and you don't really want to have your "uncaught" handler called for all those false positives (not-yet-handled "uncaught errors").</p>
<p>Another more common suggestion is that Promises should have a <code>done(..)</code> added to them, which essentially marks the Promise chain as "done." <code>done(..)</code> doesn't create and return a Promise, so the callbacks passed to <code>done(..)</code> are obviously not wired up to report problems to a chained Promise that doesn't exist.</p>
<p>So what happens instead? It's treated as you might usually expect in uncaught error conditions: any exception inside a <code>done(..)</code> rejection handler would be thrown as a global uncaught error (in the developer console, basically):</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// numbers don't have string functions,</span>
    <span class="token comment">// so will throw an error</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> msg<span class="token punctuation">.</span><span class="token method function property-access">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">done</span><span class="token punctuation">(</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span> handleErrors <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// if `handleErrors(..)` caused its own exception, it would</span>
<span class="token comment">// be thrown globally here</span>
</code></pre>
<p>This might sound more attractive than the never-ending chain or the arbitrary timeouts. But the biggest problem is that it's not part of the ES6 standard, so no matter how good it sounds, at best it's a lot longer way off from being a reliable and ubiquitous solution.</p>
<p>Are we just stuck, then? Not entirely.</p>
<p>Browsers have a unique capability that our code does not have: they can track and know for sure when any object gets thrown away and garbage collected. So, browsers can track Promise objects, and whenever they get garbage collected, if they have a rejection in them, the browser knows for sure this was a legitimate "uncaught error," and can thus confidently know it should report it to the developer console.</p>
<p>Note: At the time of this writing, both Chrome and Firefox have early attempts at that sort of "uncaught rejection" capability, though support is incomplete at best.</p>
<p>However, if a Promise doesn't get garbage collected -- it's exceedingly easy for that to accidentally happen through lots of different coding patterns -- the browser's garbage collection sniffing won't help you know and diagnose that you have a silently rejected Promise laying around.</p>
<p>Is there any other alternative? Yes.</p>
<h4 id="pit-of-success"><a aria-hidden="true" class="anchor-heading" href="#pit-of-success"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Pit of Success</h4>
<p>The following is just theoretical, how Promises could be someday changed to behave. I believe it would be far superior to what we currently have. And I think this change would be possible even post-ES6 because I don't think it would break web compatibility with ES6 Promises. Moreover, it can be polyfilled/prollyfilled in, if you're careful. Let's take a look:</p>
<p>Promises could default to reporting (to the developer console) any rejection, on the next Job or event loop tick, if at that exact moment no error handler has been registered for the Promise.
For the cases where you want a rejected Promise to hold onto its rejected state for an indefinite amount of time before observing, you could call <code>defer()</code>, which suppresses automatic error reporting on that Promise.
If a Promise is rejected, it defaults to noisily reporting that fact to the developer console (instead of defaulting to silence). You can opt out of that reporting either implicitly (by registering an error handler before rejection), or explicitly (with <code>defer()</code>). In either case, you control the false positives.</p>
<p>Consider:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">reject</span><span class="token punctuation">(</span> <span class="token string">"Oops"</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">defer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// `foo(..)` is Promise-aware</span>
<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> p<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// handle `foo(..)` error</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>When we create p, we know we're going to wait a while to use/observe its rejection, so we call <code>defer()</code> -- thus no global reporting. <code>defer()</code> simply returns the same promise, for chaining purposes.</p>
<p>The promise returned from <code>foo(..)</code> gets an error handler attached right away, so it's implicitly opted out and no global reporting for it occurs either.</p>
<p>But the promise returned from the <code>then(..)</code> call has no <code>defer()</code> or error handler attached, so if it rejects (from inside either resolution handler), then it will be reported to the developer console as an uncaught error.</p>
<p>This design is a pit of success. By default, all errors are either handled or reported -- what almost all developers in almost all cases would expect. You either have to register a handler or you have to intentionally opt out, and indicate you intend to defer error handling until later; you're opting for the extra responsibility in just that specific case.</p>
<p>The only real danger in this approach is if you <code>defer()</code> a Promise but then fail to actually ever observe/handle its rejection.</p>
<p>But you had to intentionally call <code>defer()</code> to opt into that pit of despair -- the default was the pit of success -- so there's not much else we could do to save you from your own mistakes.</p>
<p>I think there's still hope for Promise error handling (post-ES6). I hope the powers that be will rethink the situation and consider this alternative. In the meantime, you can implement this yourself (a challenging exercise for the reader!), or use a smarter Promise library that does so for you!</p>
<p>Note: This exact model for error handling/reporting is implemented in my asynquence Promise abstraction library, which will be discussed in Appendix A of this book.</p>
<h3 id="promise-patterns"><a aria-hidden="true" class="anchor-heading" href="#promise-patterns"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise Patterns</h3>
<p>We've already implicitly seen the sequence pattern with Promise chains (this-then-this-then-that flow control) but there are lots of variations on asynchronous patterns that we can build as abstractions on top of Promises. These patterns serve to simplify the expression of async flow control -- which helps make our code more reason-able and more maintainable -- even in the most complex parts of our programs.</p>
<p>Two such patterns are codified directly into the native ES6 Promise implementation, so we get them for free, to use as building blocks for other patterns.</p>
<h4 id="promiseall--"><a aria-hidden="true" class="anchor-heading" href="#promiseall--"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise.all([ .. ])</h4>
<p>In an async sequence (Promise chain), only one async task is being coordinated at any given moment -- step 2 strictly follows step 1, and step 3 strictly follows step 2. But what about doing two or more steps concurrently (aka "in parallel")?</p>
<p>In classic programming terminology, a "gate" is a mechanism that waits on two or more parallel/concurrent tasks to complete before continuing. It doesn't matter what order they finish in, just that all of them have to complete for the gate to open and let the flow control through.</p>
<p>In the Promise API, we call this pattern all([ .. ]).</p>
<p>Say you wanted to make two Ajax requests at the same time, and wait for both to finish, regardless of their order, before making a third Ajax request. Consider:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// `request(..)` is a Promise-aware Ajax utility,</span>
<span class="token comment">// like we defined earlier in the chapter</span>

<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.1/"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.2/"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">]</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msgs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// both `p1` and `p2` fulfill and pass in</span>
  <span class="token comment">// their messages here</span>
  <span class="token keyword control-flow">return</span> <span class="token function">request</span><span class="token punctuation">(</span>
    <span class="token string">"http://some.url.3/?v="</span> <span class="token operator">+</span> msgs<span class="token punctuation">.</span><span class="token method function property-access">join</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> msg <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><code>Promise.all([ .. ])</code> expects a single argument, an array, consisting generally of Promise instances. The promise returned from the <code>Promise.all([ .. ])</code> call will receive a fulfillment message (msgs in this snippet) that is an array of all the fulfillment messages from the passed in promises, in the same order as specified (regardless of fulfillment order).</p>
<p>Note: Technically, the array of values passed into <code>Promise.all([ .. ])</code> can include Promises, thenables, or even immediate values. Each value in the list is essentially passed through <code>Promise.resolve(..)</code> to make sure it's a genuine Promise to be waited on, so an immediate value will just be normalized into a Promise for that value. If the array is empty, the main Promise is immediately fulfilled.</p>
<p>The main promise returned from <code>Promise.all([ .. ])</code> will only be fulfilled if and when all its constituent promises are fulfilled. If any one of those promises instead is rejected, the main <code>Promise.all([ .. ])</code> promise is immediately rejected, discarding all results from any other promises.</p>
<p>Remember to always attach a rejection/error handler to every promise, even and especially the one that comes back from <code>Promise.all([ .. ])</code>.</p>
<h4 id="promiserace--"><a aria-hidden="true" class="anchor-heading" href="#promiserace--"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise.race([ .. ])</h4>
<p>While <code>Promise.all([ .. ])</code> coordinates multiple Promises concurrently and assumes all are needed for fulfillment, sometimes you only want to respond to the "first Promise to cross the finish line," letting the other Promises fall away.</p>
<p>This pattern is classically called a "latch," but in Promises it's called a "race."</p>
<p>Warning: While the metaphor of "only the first across the finish line wins" fits the behavior well, unfortunately "race" is kind of a loaded term, because "race conditions" are generally taken as bugs in programs (see Chapter 1). Don't confuse <code>Promise.race([ .. ])</code> with "race condition".</p>
<p><code>Promise.race([ .. ])</code> also expects a single array argument, containing one or more Promises, thenables, or immediate values. It doesn't make much practical sense to have a race with immediate values, because the first one listed will obviously win -- like a foot race where one runner starts at the finish line!</p>
<p>Similar to <code>Promise.all([ .. ])</code>, <code>Promise.race([ .. ])</code> will fulfill if and when any Promise resolution is a fulfillment, and it will reject if and when any Promise resolution is a rejection.</p>
<p>Warning: A "race" requires at least one "runner," so if you pass an empty array, instead of immediately resolving, the main race([..]) Promise will never resolve. This is a footgun! ES6 should have specified that it either fulfills, rejects, or just throws some sort of synchronous error. Unfortunately, because of precedence in Promise libraries predating ES6 Promise, they had to leave this gotcha in there, so be careful never to send in an empty array.</p>
<p>Let's revisit our previous concurrent Ajax example, but in the context of a race between p1 and p2:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// `request(..)` is a Promise-aware Ajax utility,</span>
<span class="token comment">// like we defined earlier in the chapter</span>

<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.1/"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.2/"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">race</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">]</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// either `p1` or `p2` will win the race</span>
  <span class="token keyword control-flow">return</span> <span class="token function">request</span><span class="token punctuation">(</span>
    <span class="token string">"http://some.url.3/?v="</span> <span class="token operator">+</span> msg
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> msg <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Because only one promise wins, the fulfillment value is a single message, not an array as it was for <code>Promise.all([ .. ])</code>.</p>
<h5 id="timeout-race"><a aria-hidden="true" class="anchor-heading" href="#timeout-race"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Timeout Race</h5>
<p>We saw this example earlier, illustrating how <code>Promise.race([ .. ])</code> can be used to express the "promise timeout" pattern:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// `foo()` is a Promise-aware function</span>

<span class="token comment">// `timeoutPromise(..)`, defined ealier, returns</span>
<span class="token comment">// a Promise that rejects after a specified delay</span>

<span class="token comment">// setup a timeout for `foo()`</span>
<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">race</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment">// attempt `foo()`</span>
  <span class="token function">timeoutPromise</span><span class="token punctuation">(</span> <span class="token number">3000</span> <span class="token punctuation">)</span>  <span class="token comment">// give it 3 seconds</span>
<span class="token punctuation">]</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// `foo(..)` fulfilled in time!</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// either `foo()` rejected, or it just</span>
    <span class="token comment">// didn't finish in time, so inspect</span>
    <span class="token comment">// `err` to know which</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>This timeout pattern works well in most cases. But there are some nuances to consider, and frankly they apply to both <code>Promise.race([ .. ])</code> and <code>Promise.all([ .. ])</code> equally.</p>
<h5 id="finally-1"><a aria-hidden="true" class="anchor-heading" href="#finally-1"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>"Finally"</h5>
<p>The key question to ask is, "What happens to the promises that get discarded/ignored?" We're not asking that question from the performance perspective -- they would typically end up garbage collection eligible -- but from the behavioral perspective (side effects, etc.). Promises cannot be canceled -- and shouldn't be as that would destroy the external immutability trust discussed in the "Promise Uncancelable" section later in this chapter -- so they can only be silently ignored.</p>
<p>But what if <code>foo()</code> in the previous example is reserving some sort of resource for usage, but the timeout fires first and causes that promise to be ignored? Is there anything in this pattern that proactively frees the reserved resource after the timeout, or otherwise cancels any side effects it may have had? What if all you wanted was to log the fact that foo() timed out?</p>
<p>Some developers have proposed that Promises need a <code>finally(..)</code> callback registration, which is always called when a Promise resolves, and allows you to specify any cleanup that may be necessary. This doesn't exist in the specification at the moment, but it may come in ES7+. We'll have to wait and see.</p>
<p>It might look like:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> something <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword control-flow">finally</span><span class="token punctuation">(</span> cleanup <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> another <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword control-flow">finally</span><span class="token punctuation">(</span> cleanup <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Note: In various Promise libraries, <code>finally(..)</code> still creates and returns a new Promise (to keep the chain going). If the <code>cleanup(..)</code> function were to return a Promise, it would be linked into the chain, which means you could still have the unhandled rejection issues we discussed earlier.</p>
<p>In the meantime, we could make a static helper utility that lets us observe (without interfering) the resolution of a Promise:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// polyfill-safe guard check</span>
<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token property-access">observe</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">observe</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">pr<span class="token punctuation">,</span>cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// side-observe `pr`'s resolution</span>
    pr<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
      <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// schedule callback async (as Job)</span>
        <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> msg <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> cb <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// schedule callback async (as Job)</span>
        <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> cb <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// return original promise</span>
    <span class="token keyword control-flow">return</span> pr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Here's how we'd use it in the timeout example from before:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">race</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>
  <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">observe</span><span class="token punctuation">(</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment">// attempt `foo()`</span>
    <span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// clean up after `foo()`, even if it</span>
      <span class="token comment">// didn't finish before the timeout</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">timeoutPromise</span><span class="token punctuation">(</span> <span class="token number">3000</span> <span class="token punctuation">)</span>  <span class="token comment">// give it 3 seconds</span>
<span class="token punctuation">]</span> <span class="token punctuation">)</span>
</code></pre>
<p>This <code>Promise.observe(..)</code> helper is just an illustration of how you could observe the completions of Promises without interfering with them. Other Promise libraries have their own solutions. Regardless of how you do it, you'll likely have places where you want to make sure your Promises aren't just silently ignored by accident.</p>
<h4 id="variations-on-all---and-race--"><a aria-hidden="true" class="anchor-heading" href="#variations-on-all---and-race--"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Variations on all([ .. ]) and race([ .. ])</h4>
<p>While native ES6 Promises come with built-in <code>Promise.all([ .. ])</code> and <code>Promise.race([ .. ])</code>, there are several other commonly used patterns with variations on those semantics:</p>
<ul>
<li><code>none([ .. ])</code> is like <code>all([ .. ])</code>, but fulfillments and rejections are transposed. All Promises need to be rejected -- rejections become the fulfillment values and vice versa.</li>
<li><code>any([ .. ])</code> is like <code>all([ .. ])</code>, but it ignores any rejections, so only one needs to fulfill instead of all of them.</li>
<li><code>first([ .. ])</code> is like a race with <code>any([ .. ])</code>, which is that it ignores any rejections and fulfills as soon as the first Promise fulfills.</li>
<li><code>last([ .. ])</code> is like <code>first([ .. ])</code>, but only the latest fulfillment wins.</li>
</ul>
<p>Some Promise abstraction libraries provide these, but you could also define them yourself using the mechanics of Promises, <code>race([ .. ])</code> and <code>all([ .. ])</code>.</p>
<p>For example, here's how we could define <code>first([ .. ])</code>:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// polyfill-safe guard check</span>
<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token property-access">first</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">first</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">prs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// loop through all promises</span>
      prs<span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">pr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// normalize the value</span>
        <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> pr <span class="token punctuation">)</span>
        <span class="token comment">// whichever one fulfills first wins, and</span>
        <span class="token comment">// gets to resolve the main promise</span>
        <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> resolve <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Note: This implementation of <code>first(..)</code> does not reject if all its promises reject; it simply hangs, much like a <code>Promise.race([])</code> does. If desired, you could add additional logic to track each promise rejection and if all reject, call <code>reject()</code> on the main promise. We'll leave that as an exercise for the reader.</p>
<h4 id="concurrent-iterations"><a aria-hidden="true" class="anchor-heading" href="#concurrent-iterations"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Concurrent Iterations</h4>
<p>Sometimes you want to iterate over a list of Promises and perform some task against all of them, much like you can do with synchronous arrays (e.g., <code>forEach(..)</code>, <code>map(..)</code>, <code>some(..)</code>, and <code>every(..)</code>). If the task to perform against each Promise is fundamentally synchronous, these work fine, just as we used <code>forEach(..)</code> in the previous snippet.</p>
<p>But if the tasks are fundamentally asynchronous, or can/should otherwise be performed concurrently, you can use async versions of these utilities as provided by many libraries.</p>
<p>For example, let's consider an asynchronous <code>map(..)</code> utility that takes an array of values (could be Promises or anything else), plus a function (task) to perform against each. <code>map(..)</code> itself returns a promise whose fulfillment value is an array that holds (in the same mapping order) the async fulfillment value from each task:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token property-access">map</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">map</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">vals<span class="token punctuation">,</span>cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// new promise that waits for all mapped promises</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span>
      <span class="token comment">// note: regular array `map(..)`, turns</span>
      <span class="token comment">// the array of values into an array of</span>
      <span class="token comment">// promises</span>
      vals<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// replace `val` with a new promise that</span>
        <span class="token comment">// resolves after `val` is async mapped</span>
        <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">cb</span><span class="token punctuation">(</span> val<span class="token punctuation">,</span> resolve <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Note: In this implementation of <code>map(..)</code>, you can't signal async rejection, but if a synchronous exception/error occurs inside of the mapping callback (cb(..)), the main <code>Promise.map(..)</code> returned promise would reject.</p>
<p>Let's illustrate using <code>map(..)</code> with a list of Promises (instead of simple values):</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">21</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p3 <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">reject</span><span class="token punctuation">(</span> <span class="token string">"Oops"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// double values in list even if they're in</span>
<span class="token comment">// Promises</span>
<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">pr<span class="token punctuation">,</span>done</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// make sure the item itself is a Promise</span>
  <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> pr <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
    <span class="token comment">// extract value as `v`</span>
    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// map fulfillment `v` to new value</span>
      <span class="token function">done</span><span class="token punctuation">(</span> v <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// or, map to promise rejection message</span>
    done
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">vals</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> vals <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [42,84,"Oops"]</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="promise-limitations"><a aria-hidden="true" class="anchor-heading" href="#promise-limitations"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise Limitations</h3>
<p>Many of the details we'll discuss in this section have already been alluded to in this chapter, but we'll just make sure to review these limitations specifically.</p>
<h4 id="sequence-error-handling"><a aria-hidden="true" class="anchor-heading" href="#sequence-error-handling"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Sequence Error Handling</h4>
<p>We covered Promise-flavored error handling in detail earlier in this chapter. The limitations of how Promises are designed -- how they chain, specifically -- creates a very easy pitfall where an error in a Promise chain can be silently ignored accidentally.</p>
<p>But there's something else to consider with Promise errors. Because a Promise chain is nothing more than its constituent Promises wired together, there's no entity to refer to the entire chain as a single thing, which means there's no external way to observe any errors that may occur.</p>
<p>If you construct a Promise chain that has no error handling in it, any error anywhere in the chain will propagate indefinitely down the chain, until observed (by registering a rejection handler at some step). So, in that specific case, having a reference to the last promise in the chain is enough (p in the following snippet), because you can register a rejection handler there, and it will be notified of any propagated errors:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// `foo(..)`, `STEP2(..)` and `STEP3(..)` are</span>
<span class="token comment">// all promise-aware utilities</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token constant">STEP2</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token constant">STEP3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Although it may seem sneakily confusing, p here doesn't point to the first promise in the chain (the one from the foo(42) call), but instead from the last promise, the one that comes from the then(STEP3) call.</p>
<p>Also, no step in the promise chain is observably doing its own error handling. That means that you could then register a rejection error handler on p, and it would be notified if any errors occur anywhere in the chain:</p>
<pre class="language-javascript"><code class="language-javascript">p<span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span> handleErrors <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>But if any step of the chain in fact does its own error handling (perhaps hidden/abstracted away from what you can see), your <code>handleErrors(..)</code> won't be notified. This may be what you want -- it was, after all, a "handled rejection" -- but it also may not be what you want. The complete lack of ability to be notified (of "already handled" rejection errors) is a limitation that restricts capabilities in some use cases.</p>
<p>It's basically the same limitation that exists with a <code>try..catch</code> that can catch an exception and simply swallow it. So this isn't a limitation unique to Promises, but it is something we might wish to have a workaround for.</p>
<p>Unfortunately, many times there is no reference kept for the intermediate steps in a Promise-chain sequence, so without such references, you cannot attach error handlers to reliably observe the errors.</p>
<h4 id="single-value"><a aria-hidden="true" class="anchor-heading" href="#single-value"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Single Value</h4>
<p>Promises by definition only have a single fulfillment value or a single rejection reason. In simple examples, this isn't that big of a deal, but in more sophisticated scenarios, you may find this limiting.</p>
<p>The typical advice is to construct a values wrapper (such as an object or array) to contain these multiple messages. This solution works, but it can be quite awkward and tedious to wrap and unwrap your messages with every single step of your Promise chain.</p>
<h5 id="splitting-values"><a aria-hidden="true" class="anchor-heading" href="#splitting-values"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Splitting Values</h5>
<p>Sometimes you can take this as a signal that you could/should decompose the problem into two or more Promises.</p>
<p>Imagine you have a utility <code>foo(..)</code> that produces two values (x and y) asynchronously:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">bar<span class="token punctuation">,</span>baz</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> bar <span class="token operator">*</span> baz<span class="token punctuation">;</span>

  <span class="token keyword control-flow">return</span> <span class="token function">getY</span><span class="token punctuation">(</span> x <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// wrap both values into container</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msgs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> msgs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> msgs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> x<span class="token punctuation">,</span> y <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 200 599</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>First, let's rearrange what <code>foo(..)</code> returns so that we don't have to wrap x and y into a single array value to transport through one Promise. Instead, we can wrap each value into its own promise:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">bar<span class="token punctuation">,</span>baz</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> bar <span class="token operator">*</span> baz<span class="token punctuation">;</span>

  <span class="token comment">// return both promises</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">[</span>
    <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">resolve</span><span class="token punctuation">(</span> x <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">getY</span><span class="token punctuation">(</span> x <span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span>
  <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msgs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> msgs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> msgs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> x<span class="token punctuation">,</span> y <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Is an array of promises really better than an array of values passed through a single promise? Syntactically, it's not much of an improvement.</p>
<p>But this approach more closely embraces the Promise design theory. It's now easier in the future to refactor to split the calculation of x and y into separate functions. It's cleaner and more flexible to let the calling code decide how to orchestrate the two promises -- using <code>Promise.all([ .. ])</code> here, but certainly not the only option -- rather than to abstract such details away inside of <code>foo(..)</code>.</p>
<h5 id="unwrapspread-arguments"><a aria-hidden="true" class="anchor-heading" href="#unwrapspread-arguments"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Unwrap/Spread Arguments</h5>
<p>The <code>var x = ..</code> and <code>var y = ..</code> assignments are still awkward overhead. We can employ some functional trickery (hat tip to Reginald Braithwaite, <a title="Private" style="color: brown" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank">@raganwald (Private)</a> on Twitter) in a helper utility:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Function</span><span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span> fn<span class="token punctuation">,</span> <span class="token keyword null nil">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span>
  <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
  <span class="token function">spread</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> x<span class="token punctuation">,</span> y <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 200 599</span>
  <span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre>
<p>That's a bit nicer! Of course, you could inline the functional magic to avoid the extra helper:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span>
  <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token known-class-name class-name">Function</span><span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">.</span><span class="token method function property-access">bind</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> x<span class="token punctuation">,</span> y <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 200 599</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword null nil">null</span>
<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>These tricks may be neat, but ES6 has an even better answer for us: destructuring. The array destructuring assignment form looks like this:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span>
  <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msgs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> msgs<span class="token punctuation">;</span>

  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> x<span class="token punctuation">,</span> y <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 200 599</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>But best of all, ES6 offers the array parameter destructuring form:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">all</span><span class="token punctuation">(</span>
  <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> x<span class="token punctuation">,</span> y <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 200 599</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>We've now embraced the one-value-per-Promise mantra, but kept our supporting boilerplate to a minimum!</p>
<p>Note: For more information on ES6 destructuring forms, see the ES6 &#x26; Beyond title of this series.</p>
<h4 id="single-resolution"><a aria-hidden="true" class="anchor-heading" href="#single-resolution"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Single Resolution</h4>
<p>One of the most intrinsic behaviors of Promises is that a Promise can only be resolved once (fulfillment or rejection). For many async use cases, you're only retrieving a value once, so this works fine.</p>
<p>But there's also a lot of async cases that fit into a different model -- one that's more akin to events and/or streams of data. It's not clear on the surface how well Promises can fit into such use cases, if at all. Without a significant abstraction on top of Promises, they will completely fall short for handling multiple value resolution.</p>
<p>Imagine a scenario where you might want to fire off a sequence of async steps in response to a stimulus (like an event) that can in fact happen multiple times, like a button click.</p>
<p>This probably won't work the way you want:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// `click(..)` binds the `"click"` event to a DOM element</span>
<span class="token comment">// `request(..)` is the previously defined Promise-aware Ajax</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">click</span><span class="token punctuation">(</span> <span class="token string">"#mybtn"</span><span class="token punctuation">,</span> resolve <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">var</span> btnID <span class="token operator">=</span> evt<span class="token punctuation">.</span><span class="token property-access">currentTarget</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span>
	<span class="token keyword control-flow">return</span> <span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.1/?id="</span> <span class="token operator">+</span> btnID <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> text <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The behavior here only works if your application calls for the button to be clicked just once. If the button is clicked a second time, the p promise has already been resolved, so the second resolve(..) call would be ignored.</p>
<p>Instead, you'd probably need to invert the paradigm, creating a whole new Promise chain for each event firing:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token function">click</span><span class="token punctuation">(</span> <span class="token string">"#mybtn"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">var</span> btnID <span class="token operator">=</span> evt<span class="token punctuation">.</span><span class="token property-access">currentTarget</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">;</span>

	<span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.1/?id="</span> <span class="token operator">+</span> btnID <span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> text <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>This approach will work in that a whole new Promise sequence will be fired off for each "click" event on the button.</p>
<p>But beyond just the ugliness of having to define the entire Promise chain inside the event handler, this design in some respects violates the idea of separation of concerns/capabilities (SoC). You might very well want to define your event handler in a different place in your code from where you define the response to the event (the Promise chain). That's pretty awkward to do in this pattern, without helper mechanisms.</p>
<p>Note: Another way of articulating this limitation is that it'd be nice if we could construct some sort of "observable" that we can subscribe a Promise chain to. There are libraries that have created these abstractions (such as <a href="http://rxjs.codeplex.com/">RxJS</a>), but the abstractions can seem so heavy that you can't even see the nature of Promises anymore. Such heavy abstraction brings important questions to mind such as whether (sans Promises) these mechanisms are as trustable as Promises themselves have been designed to be. We'll revisit the "Observable" pattern in Appendix B.</p>
<h4 id="inertia"><a aria-hidden="true" class="anchor-heading" href="#inertia"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Inertia</h4>
<p>One concrete barrier to starting to use Promises in your own code is all the code that currently exists which is not already Promise-aware. If you have lots of callback-based code, it's far easier to just keep coding in that same style.</p>
<p>"A code base in motion (with callbacks) will remain in motion (with callbacks) unless acted upon by a smart, Promises-aware developer."</p>
<p>Promises offer a different paradigm, and as such, the approach to the code can be anywhere from just a little different to, in some cases, radically different. You have to be intentional about it, because Promises will not just naturally shake out from the same ol' ways of doing code that have served you well thus far.</p>
<p>Consider a callback-based scenario like the following:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">ajax</span><span class="token punctuation">(</span>
		<span class="token string">"http://some.url.1/?x="</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">"&#x26;y="</span> <span class="token operator">+</span> y<span class="token punctuation">,</span>
		cb
	<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
		<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> text <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Is it immediately obvious what the first steps are to convert this callback-based code to Promise-aware code? Depends on your experience. The more practice you have with it, the more natural it will feel. But certainly, Promises don't just advertise on the label exactly how to do it -- there's no one-size-fits-all answer -- so the responsibility is up to you.</p>
<p>As we've covered before, we definitely need an Ajax utility that is Promise-aware instead of callback-based, which we could call <code>request(..)</code>. You can make your own, as we have already. But the overhead of having to manually define Promise-aware wrappers for every callback-based utility makes it less likely you'll choose to refactor to Promise-aware coding at all.</p>
<p>Promises offer no direct answer to that limitation. Most Promise libraries do offer a helper, however. But even without a library, imagine a helper like this:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// polyfill-safe guard check</span>
<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token property-access">wrap</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">wrap</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword control-flow">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token method function property-access">slice</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				fn<span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span>
					<span class="token keyword null nil">null</span><span class="token punctuation">,</span>
					args<span class="token punctuation">.</span><span class="token method function property-access">concat</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
						<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
							<span class="token function">reject</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token punctuation">}</span>
						<span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
							<span class="token function">resolve</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token punctuation">}</span>
					<span class="token punctuation">}</span> <span class="token punctuation">)</span>
				<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>OK, that's more than just a tiny trivial utility. However, although it may look a bit intimidating, it's not as bad as you'd think. It takes a function that expects an error-first style callback as its last parameter, and returns a new one that automatically creates a Promise to return, and substitutes the callback for you, wired up to the Promise fulfillment/rejection.</p>
<p>Rather than waste too much time talking about how this <code>Promise.wrap(..)</code> helper works, let's just look at how we use it:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> request <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">wrap</span><span class="token punctuation">(</span> ajax <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.1/"</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre>
<p>Wow, that was pretty easy!</p>
<p><code>Promise.wrap(..)</code> does not produce a Promise. It produces a function that will produce Promises. In a sense, a Promise-producing function could be seen as a "Promise factory." I propose "promisory" as the name for such a thing ("Promise" + "factory").</p>
<p>The act of wrapping a callback-expecting function to be a Promise-aware function is sometimes referred to as "lifting" or "promisifying". But there doesn't seem to be a standard term for what to call the resultant function other than a "lifted function", so I like "promisory" better as I think it's more descriptive.</p>
<p>Note: Promisory isn't a made-up term. It's a real word, and its definition means to contain or convey a promise. That's exactly what these functions are doing, so it turns out to be a pretty perfect terminology match!</p>
<p>So, <code>Promise.wrap(ajax)</code> produces an <code>ajax(..)</code> promisory we call <code>request(..)</code>, and that promisory produces Promises for Ajax responses.</p>
<p>If all functions were already promisories, we wouldn't need to make them ourselves, so the extra step is a tad bit of a shame. But at least the wrapping pattern is (usually) repeatable so we can put it into a <code>Promise.wrap(..)</code> helper as shown to aid our promise coding.</p>
<p>So back to our earlier example, we need a promisory for both <code>ajax(..)</code> and <code>foo(..)</code>:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// make a promisory for `ajax(..)`</span>
<span class="token keyword">var</span> request <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">wrap</span><span class="token punctuation">(</span> ajax <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// refactor `foo(..)`, but keep it externally</span>
<span class="token comment">// callback-based for compatibility with other</span>
<span class="token comment">// parts of the code for now -- only use</span>
<span class="token comment">// `request(..)`'s promise internally.</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">request</span><span class="token punctuation">(</span>
		<span class="token string">"http://some.url.1/?x="</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">"&#x26;y="</span> <span class="token operator">+</span> y
	<span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
		<span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">cb</span><span class="token punctuation">(</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span> text <span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
		cb
	<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// now, for this code's purposes, make a</span>
<span class="token comment">// promisory for `foo(..)`</span>
<span class="token keyword">var</span> betterFoo <span class="token operator">=</span> <span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">wrap</span><span class="token punctuation">(</span> foo <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// and use the promisory</span>
<span class="token function">betterFoo</span><span class="token punctuation">(</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">31</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
	<span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span> text <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">error</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Of course, while we're refactoring <code>foo(..)</code> to use our new <code>request(..)</code> promisory, we could just make <code>foo(..)</code> a promisory itself, instead of remaining callback-based and needing to make and use the subsequent <code>betterFoo(..)</code> promisory. This decision just depends on whether <code>foo(..)</code> needs to stay callback-based compatible with other parts of the code base or not.</p>
<p>Consider:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// `foo(..)` is now also a promisory because it</span>
<span class="token comment">// delegates to the `request(..)` promisory</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword control-flow">return</span> <span class="token function">request</span><span class="token punctuation">(</span>
		<span class="token string">"http://some.url.1/?x="</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">"&#x26;y="</span> <span class="token operator">+</span> y
	<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">31</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre>
<p>While ES6 Promises don't natively ship with helpers for such promisory wrapping, most libraries provide them, or you can make your own. Either way, this particular limitation of Promises is addressable without too much pain (certainly compared to the pain of callback hell!).</p>
<h4 id="promise-uncancelable"><a aria-hidden="true" class="anchor-heading" href="#promise-uncancelable"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise Uncancelable</h4>
<p>Once you create a Promise and register a fulfillment and/or rejection handler for it, there's nothing external you can do to stop that progression if something else happens to make that task moot.</p>
<p>Note: Many Promise abstraction libraries provide facilities to cancel Promises, but this is a terrible idea! Many developers wish Promises had natively been designed with external cancelation capability, but the problem is that it would let one consumer/observer of a Promise affect some other consumer's ability to observe that same Promise. This violates the future-value's trustability (external immutability), but moreover is the embodiment of the <a href="http://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_programming%29">"action at a distance" anti-pattern</a>. Regardless of how useful it seems, it will actually lead you straight back into the same nightmares as callbacks.</p>
<p>Consider our Promise timeout scenario from earlier:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">race</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>
	p<span class="token punctuation">,</span>
	<span class="token function">timeoutPromise</span><span class="token punctuation">(</span> <span class="token number">3000</span> <span class="token punctuation">)</span>
<span class="token punctuation">]</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
	doSomething<span class="token punctuation">,</span>
	handleError
<span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// still happens even in the timeout case :(</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The "timeout" was external to the promise p, so p itself keeps going, which we probably don't want.</p>
<p>One option is to invasively define your resolution callbacks:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token constant">OK</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token known-class-name class-name">Promise</span><span class="token punctuation">.</span><span class="token method function property-access">race</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>
	p<span class="token punctuation">,</span>
	<span class="token function">timeoutPromise</span><span class="token punctuation">(</span> <span class="token number">3000</span> <span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token keyword control-flow">catch</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token constant">OK</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword control-flow">throw</span> err<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token punctuation">)</span>
<span class="token punctuation">]</span> <span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span>
	doSomething<span class="token punctuation">,</span>
	handleError
<span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token constant">OK</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// only happens if no timeout! :)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>This is ugly. It works, but it's far from ideal. Generally, you should try to avoid such scenarios.</p>
<p>But if you can't, the ugliness of this solution should be a clue that cancelation is a functionality that belongs at a higher level of abstraction on top of Promises. I'd recommend you look to Promise abstraction libraries for assistance rather than hacking it yourself.</p>
<p>Note: My asynquence Promise abstraction library provides just such an abstraction and an <code>abort()</code> capability for the sequence, all of which will be discussed in Appendix A.</p>
<p>A single Promise is not really a flow-control mechanism (at least not in a very meaningful sense), which is exactly what cancelation refers to; that's why Promise cancelation would feel awkward.</p>
<p>By contrast, a chain of Promises taken collectively together -- what I like to call a "sequence" -- is a flow control expression, and thus it's appropriate for cancelation to be defined at that level of abstraction.</p>
<p>No individual Promise should be cancelable, but it's sensible for a sequence to be cancelable, because you don't pass around a sequence as a single immutable value like you do with a Promise.</p>
<h4 id="promise-performance"><a aria-hidden="true" class="anchor-heading" href="#promise-performance"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Promise Performance</h4>
<p>This particular limitation is both simple and complex.</p>
<p>Comparing how many pieces are moving with a basic callback-based async task chain versus a Promise chain, it's clear Promises have a fair bit more going on, which means they are naturally at least a tiny bit slower. Think back to just the simple list of trust guarantees that Promises offer, as compared to the ad hoc solution code you'd have to layer on top of callbacks to achieve the same protections.</p>
<p>More work to do, more guards to protect, means that Promises are slower as compared to naked, untrustable callbacks. That much is obvious, and probably simple to wrap your brain around.</p>
<p>But how much slower? Well... that's actually proving to be an incredibly difficult question to answer absolutely, across the board.</p>
<p>Frankly, it's kind of an apples-to-oranges comparison, so it's probably the wrong question to ask. You should actually compare whether an ad-hoc callback system with all the same protections manually layered in is faster than a Promise implementation.</p>
<p>If Promises have a legitimate performance limitation, it's more that they don't really offer a line-item choice as to which trustability protections you want/need or not -- you get them all, always.</p>
<p>Nevertheless, if we grant that a Promise is generally a little bit slower than its non-Promise, non-trustable callback equivalent -- assuming there are places where you feel you can justify the lack of trustability -- does that mean that Promises should be avoided across the board, as if your entire application is driven by nothing but must-be-utterly-the-fastest code possible?</p>
<p>Sanity check: if your code is legitimately like that, is JavaScript even the right language for such tasks? JavaScript can be optimized to run applications very performantly (see Chapter 5 and Chapter 6). But is obsessing over tiny performance tradeoffs with Promises, in light of all the benefits they offer, really appropriate?</p>
<p>Another subtle issue is that Promises make everything async, which means that some immediately (synchronously) complete steps still defer advancement of the next step to a Job (see Chapter 1). That means that it's possible that a sequence of Promise tasks could complete ever-so-slightly slower than the same sequence wired up with callbacks.</p>
<p>Of course, the question here is this: are these potential slips in tiny fractions of performance worth all the other articulated benefits of Promises we've laid out across this chapter?</p>
<p>My take is that in virtually all cases where you might think Promise performance is slow enough to be concerned, it's actually an anti-pattern to optimize away the benefits of Promise trustability and composability by avoiding them altogether.</p>
<p>Instead, you should default to using them across the code base, and then profile and analyze your application's hot (critical) paths. Are Promises really a bottleneck, or are they just a theoretical slowdown? Only then, armed with actual valid benchmarks (see Chapter 6) is it responsible and prudent to factor out the Promises in just those identified critical areas.</p>
<p>Promises are a little slower, but in exchange you're getting a lot of trustability, non-Zalgo predictability, and composability built in. Maybe the limitation is not actually their performance, but your lack of perception of their benefits?</p>
<h3 id="review"><a aria-hidden="true" class="anchor-heading" href="#review"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Review</h3>
<p>Promises are awesome. Use them. They solve the inversion of control issues that plague us with callbacks-only code.</p>
<p>They don't get rid of callbacks, they just redirect the orchestration of those callbacks to a trustable intermediary mechanism that sits between us and another utility.</p>
<p>Promise chains also begin to address (though certainly not perfectly) a better way of expressing async flow in sequential fashion, which helps our brains plan and maintain async JS code better. We'll see an even better solution to that problem in the next chapter!</p>
<h2 id="source"><a aria-hidden="true" class="anchor-heading" href="#source"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Source</h2>
<p>Most of this was copied with minor edits from "You dont know JS" by Kyle Simpson</p>