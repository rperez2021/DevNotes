<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><title>CORS</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Notes on Cross Origin Resource Sharing (CORS)"/><meta property="og:title" content="CORS"/><meta property="og:description" content="Notes on Cross Origin Resource Sharing (CORS)"/><meta property="og:url" content="https://rperez2021.github.io/DevNotes/notes/mumqxu4l53t9gax6vz78ptt/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="4/7/2022"/><meta property="article:modified_time" content="4/7/2022"/><link rel="canonical" href="https://rperez2021.github.io/DevNotes/notes/mumqxu4l53t9gax6vz78ptt/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/DevNotes/_next/static/css/eed8bf81abfd52c3.css" as="style"/><link rel="stylesheet" href="/DevNotes/_next/static/css/eed8bf81abfd52c3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/DevNotes/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/DevNotes/_next/static/chunks/webpack-0c999df4017467fc.js" defer=""></script><script src="/DevNotes/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/DevNotes/_next/static/chunks/main-772151c4b16ecf54.js" defer=""></script><script src="/DevNotes/_next/static/chunks/pages/_app-12b82b1567467517.js" defer=""></script><script src="/DevNotes/_next/static/chunks/826-e0e455fb469c158f.js" defer=""></script><script src="/DevNotes/_next/static/chunks/986-737e5da213076068.js" defer=""></script><script src="/DevNotes/_next/static/chunks/pages/notes/%5Bid%5D-00dd1421f3ce3a3e.js" defer=""></script><script src="/DevNotes/_next/static/ZngNBAAOWdGj2M_dMvVk6/_buildManifest.js" defer=""></script><script src="/DevNotes/_next/static/ZngNBAAOWdGj2M_dMvVk6/_ssgManifest.js" defer=""></script><script src="/DevNotes/_next/static/ZngNBAAOWdGj2M_dMvVk6/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><section class="ant-layout side-layout-main" style="max-width:1200px;display:initial"><main class="ant-layout-content main-content" role="main" style="padding:0 24px"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="cors"><a aria-hidden="true" class="anchor-heading" href="#cors"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>CORS</h1>
<h2 id="general-info"><a aria-hidden="true" class="anchor-heading" href="#general-info"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>General Info</h2>
<p>Cross Origin Resource Sharing is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'url.url.com/api'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">'cors'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Simply adding the <code>{mode: 'cors'}</code> after the URL, as shown above, will solve our problems for now. In the future, however, you may want to look further into the implications of this restriction.</p>
<h2 id="from-javascriptinfo"><a aria-hidden="true" class="anchor-heading" href="#from-javascriptinfo"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>From Javascript.info</h2>
<p>Cross-origin requests – those sent to another domain (even a subdomain) or protocol or port – require special headers from the remote side.</p>
<h3 id="safe-requests"><a aria-hidden="true" class="anchor-heading" href="#safe-requests"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Safe requests</h3>
<p>There are two types of cross-origin requests:</p>
<ol>
<li>Safe requests.</li>
<li>All the others.</li>
</ol>
<p>Safe Requests are simpler to make, so let’s start with them.</p>
<p>A request is safe if it satisfies two conditions:</p>
<ol>
<li>Safe method: GET, POST or HEAD</li>
<li>Safe headers – the only allowed custom headers are:
<ul>
<li><code>Accept</code>,</li>
<li><code>Accept-Language</code>,</li>
<li><code>Content-Language</code>,</li>
<li><code>Content-Type</code> with the value:
<ul>
<li><code>application/x-www-form-urlencoded</code> OR</li>
<li><code>multipart/form-data</code> OR</li>
<li><code>text/plain</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Any other request is considered “unsafe”. For instance, a request with <code>PUT</code> method or with an API-Key HTTP-header does not fit the limitations.</p>
<p><strong>The essential difference is that a safe request can be made with a <code>&#x3C;form></code> or a <code>&#x3C;script></code>, without any special methods.</strong></p>
<p>So, even a very old server should be ready to accept a safe request.</p>
<p>Contrary to that, requests with non-standard headers or e.g. method DELETE can’t be created this way. For a long time JavaScript was unable to do such requests. So an old server may assume that such requests come from a privileged source, “because a webpage is unable to send them”.</p>
<p>When we try to make a unsafe request, the browser sends a special “preflight” request that asks the server – does it agree to accept such cross-origin requests, or not?</p>
<p>And, unless the server explicitly confirms that with headers, an unsafe request is not sent.</p>
<h4 id="cors-for-safe-requests"><a aria-hidden="true" class="anchor-heading" href="#cors-for-safe-requests"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>CORS for safe requests</h4>
<p>If a request is cross-origin, the browser always adds the Origin header to it.</p>
<pre class="language-header"><code class="language-header">GET /request
Host: anywhere.com
Origin: https://javascript.info
</code></pre>
<p>As you can see, the <code>Origin</code> header contains exactly the origin (domain/protocol/port), without a path.</p>
<p>The server can inspect the <code>Origin</code> and, if it agrees to accept such a request, add a special header <code>Access-Control-Allow-Origin</code> to the response. That header should contain the allowed origin (in our case <code>https://javascript.info</code>), or a star <code>*</code>. Then the response is successful, otherwise it’s an error.</p>
<p>The browser plays the role of a trusted mediator here:</p>
<ol>
<li>It ensures that the correct <code>Origin</code> is sent with a cross-origin request.</li>
<li>It checks for permitting <code>Access-Control-Allow-Origin</code> in the response, if it exists, then JavaScript is allowed to access the response, otherwise it fails with an error.</li>
</ol>
<p><img src="/DevNotes/assets/cors1.png" alt="CORS Image 1"></p>
<p>Here’s an example of a permissive server response:</p>
<pre class="language-header"><code class="language-header">200 OK
Content-Type:text/html; charset=UTF-8
Access-Control-Allow-Origin: https://javascript.info
</code></pre>
<h4 id="response-headers"><a aria-hidden="true" class="anchor-heading" href="#response-headers"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Response headers</h4>
<p>For cross-origin request, by default JavaScript may only access so-called “safe” response headers:</p>
<ul>
<li><code>Cache-Control</code></li>
<li><code>Content-Language</code></li>
<li><code>Content-Type</code></li>
<li><code>Expires</code></li>
<li><code>Last-Modified</code></li>
<li><code>Pragma</code></li>
</ul>
<p>Accessing any other response header causes an error.</p>
<p><strong>There’s no Content-Length header in the list!</strong></p>
<p>This header contains the full response length. So, if we’re downloading something and would like to track the percentage of progress, then an additional permission is required to access that header (see below).</p>
<p>To grant JavaScript access to any other response header, the server must send the Access-Control-Expose-Headers header. It contains a comma-separated list of unsafe header names that should be made accessible.</p>
<p>For example:</p>
<pre class="language-header"><code class="language-header">200 OK
Content-Type:text/html; charset=UTF-8
Content-Length: 12345
API-Key: 2c9de507f2c54aa1
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Expose-Headers: Content-Length,API-Key
</code></pre>
<p>With such an Access-Control-Expose-Headers header, the script is allowed to read the Content-Length and API-Key headers of the response.</p>
<h3 id="unsafe-requests"><a aria-hidden="true" class="anchor-heading" href="#unsafe-requests"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>"Unsafe" Requests</h3>
<p>We can use any HTTP-method: not just <code>GET/POST</code>, but also <code>PATCH</code>, <code>DELETE</code> and others.</p>
<p>Some time ago no one could even imagine that a webpage could make such requests. So there may still exist webservices that treat a non-standard method as a signal: “That’s not a browser”. They can take it into account when checking access rights.</p>
<p>So, to avoid misunderstandings, any “unsafe” request – that couldn’t be done in the old times, the browser does not make such requests right away. First, it sends a preliminary, so-called “preflight” request, to ask for permission.</p>
<p>A preflight request uses the method <code>OPTIONS</code>, no body and three headers:</p>
<ul>
<li><code>Access-Control-Request-Method</code> header has the method of the unsafe request.</li>
<li><code>Access-Control-Request-Headers</code> header provides a comma-separated list of its unsafe HTTP-headers.</li>
<li><code>Origin</code> header tells from where the request came. (such as <a href="https://javascript.info"></a>)</li>
</ul>
<p>If the server agrees to serve the requests, then it should respond with empty body, status 200 and headers:</p>
<ul>
<li><code>Access-Control-Allow-Origin</code> must be either <code>*</code> or the requesting origin, such as <a href="https://javascript.info"></a>, to allow it.</li>
<li><code>Access-Control-Allow-Methods</code> must have the allowed method.</li>
<li><code>Access-Control-Allow-Headers</code> must have a list of allowed headers.</li>
<li>Additionally, the header Access-Control-Max-Age may specify a number of seconds to cache the permissions. So the browser won’t have to send a preflight for subsequent requests that satisfy given permissions.</li>
</ul>
<p><img src="/DevNotes/assets/cors2.png" alt="CORS Image 1"></p>
<p>Let’s see how it works step-by-step on the example of a cross-origin PATCH request (this method is often used to update data):</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token keyword control-flow">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://site.com/service.json'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'PATCH'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'application/json'</span><span class="token punctuation">,</span>
    <span class="token string-property property">'API-Key'</span><span class="token operator">:</span> <span class="token string">'secret'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>There are three reasons why the request is unsafe (one is enough):</p>
<ul>
<li>Method <code>PATCH</code></li>
<li><code>Content-Type</code> is not one of: <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>text/plain</code>.</li>
<li>“Unsafe” <code>API-Key</code> header.</li>
</ul>
<h4 id="step-1-preflight-request"><a aria-hidden="true" class="anchor-heading" href="#step-1-preflight-request"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Step 1 (preflight request)</h4>
<p>Prior to sending such a request, the browser, on its own, sends a preflight request that looks like this:</p>
<pre class="language-header"><code class="language-header">OPTIONS /service.json
Host: site.com
Origin: https://javascript.info
Access-Control-Request-Method: PATCH
Access-Control-Request-Headers: Content-Type,API-Key
</code></pre>
<ul>
<li>Method: <code>OPTIONS</code>.</li>
<li>The path – exactly the same as the main request: <code>/service.json</code>.</li>
<li>Cross-origin special headers:
<ul>
<li><code>Origin</code> – the source origin.</li>
<li><code>Access-Control-Request-Method</code> – requested method.</li>
<li><code>A</code>ccess-Control-Request-Headers` – a comma-separated list of “unsafe” headers.</li>
</ul>
</li>
</ul>
<h4 id="step-2-preflight-response"><a aria-hidden="true" class="anchor-heading" href="#step-2-preflight-response"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Step 2 (preflight response)</h4>
<p>The server should respond with status 200 and the headers:</p>
<ul>
<li><code>Access-Control-Allow-Origin: https://javascript.info</code></li>
<li><code>Access-Control-Allow-Methods: PATCH</code></li>
<li><code>Access-Control-Allow-Headers: Content-Type,API-Key</code>.</li>
</ul>
<p>That allows future communication, otherwise an error is triggered.</p>
<p>If the server expects other methods and headers in the future, it makes sense to allow them in advance by adding them to the list.</p>
<p>For example, this response also allows <code>PUT</code>, <code>DELETE</code> and additional headers:</p>
<pre class="language-header"><code class="language-header">200 OK
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Allow-Methods: PUT,PATCH,DELETE
Access-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control
Access-Control-Max-Age: 86400
</code></pre>
<p>Now the browser can see that <code>PATCH</code> is in <code>Access-Control-Allow-Methods</code> and <code>Content-Type,API-Key</code> are in the list <code>Access-Control-Allow-Headers</code>, so it sends out the main request.</p>
<p>If there’s the header <code>Access-Control-Max-Age</code> with a number of seconds, then the preflight permissions are cached for the given time. The response above will be cached for 86400 seconds (one day). Within this timeframe, subsequent requests will not cause a preflight. Assuming that they fit the cached allowances, they will be sent directly.</p>
<h4 id="step-3-actual-request"><a aria-hidden="true" class="anchor-heading" href="#step-3-actual-request"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Step 3 (actual request)</h4>
<p>When the preflight is successful, the browser now makes the main request. The process here is the same as for safe requests.</p>
<p>The main request has the <code>Origin</code> header (because it’s cross-origin):</p>
<pre class="language-header"><code class="language-header">PATCH /service.json
Host: site.com
Content-Type: application/json
API-Key: secret
Origin: https://javascript.info
</code></pre>
<h4 id="step-4-actual-response"><a aria-hidden="true" class="anchor-heading" href="#step-4-actual-response"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Step 4 (actual response)</h4>
<p>The server should not forget to add Access-Control-Allow-Origin to the main response. A successful preflight does not relieve from that:</p>
<pre class="language-header"><code class="language-header">Access-Control-Allow-Origin: https://javascript.info
</code></pre>
<p>Then JavaScript is able to read the main server response.</p>
<p><strong>Please note:</strong></p>
<p>Preflight request occurs “behind the scenes”, it’s invisible to JavaScript.</p>
<p>JavaScript only gets the response to the main request or an error if there’s no server permission.</p>
<h3 id="credentials"><a aria-hidden="true" class="anchor-heading" href="#credentials"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Credentials</h3>
<p>A cross-origin request initiated by JavaScript code by default does not bring any credentials (cookies or HTTP authentication).</p>
<p>That’s uncommon for HTTP-requests. Usually, a request to <a href="http://site.com">http://site.com</a> is accompanied by all cookies from that domain. Cross-origin requests made by JavaScript methods on the other hand are an exception.</p>
<p>For example, <code>fetch('http://another.com')</code> does not send any cookies, even those (!) that belong to <code>another.com</code> domain.</p>
<p>Why?</p>
<p>That’s because a request with credentials is much more powerful than without them. If allowed, it grants JavaScript the full power to act on behalf of the user and access sensitive information using their credentials.</p>
<p>Does the server really trust the script that much? Then it must explicitly allow requests with credentials with an additional header.</p>
<p>To send credentials in fetch, we need to add the option credentials: "include", like this:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://another.com'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">credentials</span><span class="token operator">:</span> <span class="token string">"include"</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Now fetch sends cookies originating from <code>another.com</code> with request to that site.</p>
<p>If the server agrees to accept the request with credentials, it should add a header <code>Access-Control-Allow-Credentials: true</code> to the response, in addition to <code>Access-Control-Allow-Origin</code>.</p>
<p>For example:</p>
<pre class="language-header"><code class="language-header">200 OK
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Allow-Credentials: true
</code></pre>
<p>Please note: <code>Access-Control-Allow-Origin</code> is prohibited from using a star <code>*</code> for requests with credentials. Like shown above, it must provide the exact origin there. That’s an additional safety measure, to ensure that the server really knows who it trusts to make such requests.</p>
<h4 id="why-do-we-need-origin"><a aria-hidden="true" class="anchor-heading" href="#why-do-we-need-origin"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Why do we need Origin?</h4>
<p>As you probably know, there’s HTTP-header Referer, that usually contains an url of the page which initiated a network request.</p>
<p>For instance, when fetching <a href="http://google.com"></a> from <a href="http://javascript.info/some/url"></a>, the headers look like this:</p>
<pre class="language-header"><code class="language-header">Accept: */*
Accept-Charset: utf-8
Accept-Encoding: gzip,deflate,sdch
Connection: keep-alive
Host: google.com
Origin: http://javascript.info
Referer: http://javascript.info/some/url
</code></pre>
<p>As you can see, both <code>Referer</code> and <code>Origin</code> are present.</p>
<p>The questions:</p>
<p>Why <code>Origin</code> is needed, if <code>Referer</code> has even more information?
Is it possible that there’s no <code>Referer</code> or <code>Origin</code>, or is it incorrect?</p>
<ol>
<li>
<p>We need <code>Origin</code>, because sometimes <code>Referer</code> is absent. For instance, when we fetch HTTP-page from <code>HTTPS</code> (access less secure from more secure), then there’s no <code>Referer</code>.</p>
</li>
<li>
<p>The <a href="/DevNotes/notes/ipudv5n4dfw03m4lfl92zhi">Content Security Policy (CSP)</a> may forbid sending a Referer.</p>
</li>
<li>
<p>As we’ll see, fetch has options that prevent sending the Referer and even allow to change it (within the same site).</p>
</li>
<li>
<p>By specification, <code>Referer</code> is an optional HTTP-header.</p>
</li>
<li>
<p>Exactly because <code>Referer</code> is unreliable, <code>Origin</code> was invented. The browser guarantees correct <code>Origin</code> for cross-origin requests.</p>
</li>
</ol></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#general-info" title="General Info">General Info</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#from-javascriptinfo" title="From Javascript.info">From Javascript.info</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#safe-requests" title="Safe requests">Safe requests</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#cors-for-safe-requests" title="CORS for safe requests">CORS for safe requests</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#response-headers" title="Response headers">Response headers</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#unsafe-requests" title="&quot;Unsafe&quot; Requests">&quot;Unsafe&quot; Requests</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#step-1-preflight-request" title="Step 1 (preflight request)">Step 1 (preflight request)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#step-2-preflight-response" title="Step 2 (preflight response)">Step 2 (preflight response)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#step-3-actual-request" title="Step 3 (actual request)">Step 3 (actual request)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#step-4-actual-response" title="Step 4 (actual response)">Step 4 (actual response)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#credentials" title="Credentials">Credentials</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#why-do-we-need-origin" title="Why do we need Origin?">Why do we need Origin?</a></div></div></div></div></div></div></div></div></div></main><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></section></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"mumqxu4l53t9gax6vz78ptt","title":"CORS","desc":"Notes on Cross Origin Resource Sharing (CORS)","updated":1649305173495,"created":1649290147380,"custom":{},"fname":"devnotes.javascript.cors","type":"note","vault":{"fsPath":"vault"},"contentHash":"ce83be4c0a7cdfc5dd46713ef71cc275","links":[{"type":"wiki","from":{"fname":"devnotes.javascript.cors","id":"mumqxu4l53t9gax6vz78ptt","vaultName":"vault"},"value":"devnotes.content-security-policy","alias":"devnotes.content-security-policy","position":{"start":{"line":288,"column":8,"offset":11688},"end":{"line":288,"column":44,"offset":11724},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"devnotes.content-security-policy"}}],"anchors":{"general-info":{"type":"header","text":"General Info","value":"general-info","line":7,"column":0,"depth":2},"from-javascriptinfo":{"type":"header","text":"From Javascript.info","value":"from-javascriptinfo","line":19,"column":0,"depth":2},"safe-requests":{"type":"header","text":"Safe requests","value":"safe-requests","line":23,"column":0,"depth":3},"cors-for-safe-requests":{"type":"header","text":"CORS for safe requests","value":"cors-for-safe-requests","line":56,"column":0,"depth":4},"response-headers":{"type":"header","text":"Response headers","value":"response-headers","line":85,"column":0,"depth":4},"unsafe-requests":{"type":"header","text":"\"Unsafe\" Requests","value":"unsafe-requests","line":117,"column":0,"depth":3},"step-1-preflight-request":{"type":"header","text":"Step 1 (preflight request)","value":"step-1-preflight-request","line":158,"column":0,"depth":4},"step-2-preflight-response":{"type":"header","text":"Step 2 (preflight response)","value":"step-2-preflight-response","line":177,"column":0,"depth":4},"step-3-actual-request":{"type":"header","text":"Step 3 (actual request)","value":"step-3-actual-request","line":203,"column":0,"depth":4},"step-4-actual-response":{"type":"header","text":"Step 4 (actual response)","value":"step-4-actual-response","line":217,"column":0,"depth":4},"credentials":{"type":"header","text":"Credentials","value":"credentials","line":233,"column":0,"depth":3},"why-do-we-need-origin":{"type":"header","text":"Why do we need Origin?","value":"why-do-we-need-origin","line":269,"column":0,"depth":4}},"children":[],"parent":"cOSLT6ncEiScjLx1bEQKH","data":{}},"body":"\u003ch1 id=\"cors\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#cors\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eCORS\u003c/h1\u003e\n\u003ch2 id=\"general-info\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#general-info\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eGeneral Info\u003c/h2\u003e\n\u003cp\u003eCross Origin Resource Sharing is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served.\u003c/p\u003e\n\u003cpre class=\"language-javascript\"\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"token function\"\u003efetch\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'url.url.com/api'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token literal-property property\"\u003emode\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e'cors'\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSimply adding the \u003ccode\u003e{mode: 'cors'}\u003c/code\u003e after the URL, as shown above, will solve our problems for now. In the future, however, you may want to look further into the implications of this restriction.\u003c/p\u003e\n\u003ch2 id=\"from-javascriptinfo\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#from-javascriptinfo\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eFrom Javascript.info\u003c/h2\u003e\n\u003cp\u003eCross-origin requests – those sent to another domain (even a subdomain) or protocol or port – require special headers from the remote side.\u003c/p\u003e\n\u003ch3 id=\"safe-requests\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#safe-requests\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eSafe requests\u003c/h3\u003e\n\u003cp\u003eThere are two types of cross-origin requests:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSafe requests.\u003c/li\u003e\n\u003cli\u003eAll the others.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSafe Requests are simpler to make, so let’s start with them.\u003c/p\u003e\n\u003cp\u003eA request is safe if it satisfies two conditions:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSafe method: GET, POST or HEAD\u003c/li\u003e\n\u003cli\u003eSafe headers – the only allowed custom headers are:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eAccept\u003c/code\u003e,\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAccept-Language\u003c/code\u003e,\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eContent-Language\u003c/code\u003e,\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eContent-Type\u003c/code\u003e with the value:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eapplication/x-www-form-urlencoded\u003c/code\u003e OR\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emultipart/form-data\u003c/code\u003e OR\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etext/plain\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAny other request is considered “unsafe”. For instance, a request with \u003ccode\u003ePUT\u003c/code\u003e method or with an API-Key HTTP-header does not fit the limitations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThe essential difference is that a safe request can be made with a \u003ccode\u003e\u0026#x3C;form\u003e\u003c/code\u003e or a \u003ccode\u003e\u0026#x3C;script\u003e\u003c/code\u003e, without any special methods.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eSo, even a very old server should be ready to accept a safe request.\u003c/p\u003e\n\u003cp\u003eContrary to that, requests with non-standard headers or e.g. method DELETE can’t be created this way. For a long time JavaScript was unable to do such requests. So an old server may assume that such requests come from a privileged source, “because a webpage is unable to send them”.\u003c/p\u003e\n\u003cp\u003eWhen we try to make a unsafe request, the browser sends a special “preflight” request that asks the server – does it agree to accept such cross-origin requests, or not?\u003c/p\u003e\n\u003cp\u003eAnd, unless the server explicitly confirms that with headers, an unsafe request is not sent.\u003c/p\u003e\n\u003ch4 id=\"cors-for-safe-requests\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#cors-for-safe-requests\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eCORS for safe requests\u003c/h4\u003e\n\u003cp\u003eIf a request is cross-origin, the browser always adds the Origin header to it.\u003c/p\u003e\n\u003cpre class=\"language-header\"\u003e\u003ccode class=\"language-header\"\u003eGET /request\nHost: anywhere.com\nOrigin: https://javascript.info\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the \u003ccode\u003eOrigin\u003c/code\u003e header contains exactly the origin (domain/protocol/port), without a path.\u003c/p\u003e\n\u003cp\u003eThe server can inspect the \u003ccode\u003eOrigin\u003c/code\u003e and, if it agrees to accept such a request, add a special header \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e to the response. That header should contain the allowed origin (in our case \u003ccode\u003ehttps://javascript.info\u003c/code\u003e), or a star \u003ccode\u003e*\u003c/code\u003e. Then the response is successful, otherwise it’s an error.\u003c/p\u003e\n\u003cp\u003eThe browser plays the role of a trusted mediator here:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eIt ensures that the correct \u003ccode\u003eOrigin\u003c/code\u003e is sent with a cross-origin request.\u003c/li\u003e\n\u003cli\u003eIt checks for permitting \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e in the response, if it exists, then JavaScript is allowed to access the response, otherwise it fails with an error.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/DevNotes/assets/cors1.png\" alt=\"CORS Image 1\"\u003e\u003c/p\u003e\n\u003cp\u003eHere’s an example of a permissive server response:\u003c/p\u003e\n\u003cpre class=\"language-header\"\u003e\u003ccode class=\"language-header\"\u003e200 OK\nContent-Type:text/html; charset=UTF-8\nAccess-Control-Allow-Origin: https://javascript.info\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"response-headers\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#response-headers\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eResponse headers\u003c/h4\u003e\n\u003cp\u003eFor cross-origin request, by default JavaScript may only access so-called “safe” response headers:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCache-Control\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eContent-Language\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eContent-Type\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eExpires\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLast-Modified\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePragma\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAccessing any other response header causes an error.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThere’s no Content-Length header in the list!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThis header contains the full response length. So, if we’re downloading something and would like to track the percentage of progress, then an additional permission is required to access that header (see below).\u003c/p\u003e\n\u003cp\u003eTo grant JavaScript access to any other response header, the server must send the Access-Control-Expose-Headers header. It contains a comma-separated list of unsafe header names that should be made accessible.\u003c/p\u003e\n\u003cp\u003eFor example:\u003c/p\u003e\n\u003cpre class=\"language-header\"\u003e\u003ccode class=\"language-header\"\u003e200 OK\nContent-Type:text/html; charset=UTF-8\nContent-Length: 12345\nAPI-Key: 2c9de507f2c54aa1\nAccess-Control-Allow-Origin: https://javascript.info\nAccess-Control-Expose-Headers: Content-Length,API-Key\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith such an Access-Control-Expose-Headers header, the script is allowed to read the Content-Length and API-Key headers of the response.\u003c/p\u003e\n\u003ch3 id=\"unsafe-requests\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#unsafe-requests\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003e\"Unsafe\" Requests\u003c/h3\u003e\n\u003cp\u003eWe can use any HTTP-method: not just \u003ccode\u003eGET/POST\u003c/code\u003e, but also \u003ccode\u003ePATCH\u003c/code\u003e, \u003ccode\u003eDELETE\u003c/code\u003e and others.\u003c/p\u003e\n\u003cp\u003eSome time ago no one could even imagine that a webpage could make such requests. So there may still exist webservices that treat a non-standard method as a signal: “That’s not a browser”. They can take it into account when checking access rights.\u003c/p\u003e\n\u003cp\u003eSo, to avoid misunderstandings, any “unsafe” request – that couldn’t be done in the old times, the browser does not make such requests right away. First, it sends a preliminary, so-called “preflight” request, to ask for permission.\u003c/p\u003e\n\u003cp\u003eA preflight request uses the method \u003ccode\u003eOPTIONS\u003c/code\u003e, no body and three headers:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eAccess-Control-Request-Method\u003c/code\u003e header has the method of the unsafe request.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAccess-Control-Request-Headers\u003c/code\u003e header provides a comma-separated list of its unsafe HTTP-headers.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eOrigin\u003c/code\u003e header tells from where the request came. (such as \u003ca href=\"https://javascript.info\"\u003e\u003c/a\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf the server agrees to serve the requests, then it should respond with empty body, status 200 and headers:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e must be either \u003ccode\u003e*\u003c/code\u003e or the requesting origin, such as \u003ca href=\"https://javascript.info\"\u003e\u003c/a\u003e, to allow it.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAccess-Control-Allow-Methods\u003c/code\u003e must have the allowed method.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAccess-Control-Allow-Headers\u003c/code\u003e must have a list of allowed headers.\u003c/li\u003e\n\u003cli\u003eAdditionally, the header Access-Control-Max-Age may specify a number of seconds to cache the permissions. So the browser won’t have to send a preflight for subsequent requests that satisfy given permissions.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/DevNotes/assets/cors2.png\" alt=\"CORS Image 1\"\u003e\u003c/p\u003e\n\u003cp\u003eLet’s see how it works step-by-step on the example of a cross-origin PATCH request (this method is often used to update data):\u003c/p\u003e\n\u003cpre class=\"language-javascript\"\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e response \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword control-flow\"\u003eawait\u003c/span\u003e \u003cspan class=\"token function\"\u003efetch\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'https://site.com/service.json'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token literal-property property\"\u003emethod\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e'PATCH'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"token literal-property property\"\u003eheaders\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token string-property property\"\u003e'Content-Type'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e'application/json'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"token string-property property\"\u003e'API-Key'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e'secret'\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are three reasons why the request is unsafe (one is enough):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMethod \u003ccode\u003ePATCH\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eContent-Type\u003c/code\u003e is not one of: \u003ccode\u003eapplication/x-www-form-urlencoded\u003c/code\u003e, \u003ccode\u003emultipart/form-data\u003c/code\u003e, \u003ccode\u003etext/plain\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e“Unsafe” \u003ccode\u003eAPI-Key\u003c/code\u003e header.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"step-1-preflight-request\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#step-1-preflight-request\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eStep 1 (preflight request)\u003c/h4\u003e\n\u003cp\u003ePrior to sending such a request, the browser, on its own, sends a preflight request that looks like this:\u003c/p\u003e\n\u003cpre class=\"language-header\"\u003e\u003ccode class=\"language-header\"\u003eOPTIONS /service.json\nHost: site.com\nOrigin: https://javascript.info\nAccess-Control-Request-Method: PATCH\nAccess-Control-Request-Headers: Content-Type,API-Key\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eMethod: \u003ccode\u003eOPTIONS\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eThe path – exactly the same as the main request: \u003ccode\u003e/service.json\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eCross-origin special headers:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eOrigin\u003c/code\u003e – the source origin.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAccess-Control-Request-Method\u003c/code\u003e – requested method.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eA\u003c/code\u003eccess-Control-Request-Headers` – a comma-separated list of “unsafe” headers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"step-2-preflight-response\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#step-2-preflight-response\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eStep 2 (preflight response)\u003c/h4\u003e\n\u003cp\u003eThe server should respond with status 200 and the headers:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eAccess-Control-Allow-Origin: https://javascript.info\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAccess-Control-Allow-Methods: PATCH\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAccess-Control-Allow-Headers: Content-Type,API-Key\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat allows future communication, otherwise an error is triggered.\u003c/p\u003e\n\u003cp\u003eIf the server expects other methods and headers in the future, it makes sense to allow them in advance by adding them to the list.\u003c/p\u003e\n\u003cp\u003eFor example, this response also allows \u003ccode\u003ePUT\u003c/code\u003e, \u003ccode\u003eDELETE\u003c/code\u003e and additional headers:\u003c/p\u003e\n\u003cpre class=\"language-header\"\u003e\u003ccode class=\"language-header\"\u003e200 OK\nAccess-Control-Allow-Origin: https://javascript.info\nAccess-Control-Allow-Methods: PUT,PATCH,DELETE\nAccess-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control\nAccess-Control-Max-Age: 86400\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow the browser can see that \u003ccode\u003ePATCH\u003c/code\u003e is in \u003ccode\u003eAccess-Control-Allow-Methods\u003c/code\u003e and \u003ccode\u003eContent-Type,API-Key\u003c/code\u003e are in the list \u003ccode\u003eAccess-Control-Allow-Headers\u003c/code\u003e, so it sends out the main request.\u003c/p\u003e\n\u003cp\u003eIf there’s the header \u003ccode\u003eAccess-Control-Max-Age\u003c/code\u003e with a number of seconds, then the preflight permissions are cached for the given time. The response above will be cached for 86400 seconds (one day). Within this timeframe, subsequent requests will not cause a preflight. Assuming that they fit the cached allowances, they will be sent directly.\u003c/p\u003e\n\u003ch4 id=\"step-3-actual-request\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#step-3-actual-request\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eStep 3 (actual request)\u003c/h4\u003e\n\u003cp\u003eWhen the preflight is successful, the browser now makes the main request. The process here is the same as for safe requests.\u003c/p\u003e\n\u003cp\u003eThe main request has the \u003ccode\u003eOrigin\u003c/code\u003e header (because it’s cross-origin):\u003c/p\u003e\n\u003cpre class=\"language-header\"\u003e\u003ccode class=\"language-header\"\u003ePATCH /service.json\nHost: site.com\nContent-Type: application/json\nAPI-Key: secret\nOrigin: https://javascript.info\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"step-4-actual-response\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#step-4-actual-response\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eStep 4 (actual response)\u003c/h4\u003e\n\u003cp\u003eThe server should not forget to add Access-Control-Allow-Origin to the main response. A successful preflight does not relieve from that:\u003c/p\u003e\n\u003cpre class=\"language-header\"\u003e\u003ccode class=\"language-header\"\u003eAccess-Control-Allow-Origin: https://javascript.info\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen JavaScript is able to read the main server response.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePlease note:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ePreflight request occurs “behind the scenes”, it’s invisible to JavaScript.\u003c/p\u003e\n\u003cp\u003eJavaScript only gets the response to the main request or an error if there’s no server permission.\u003c/p\u003e\n\u003ch3 id=\"credentials\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#credentials\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eCredentials\u003c/h3\u003e\n\u003cp\u003eA cross-origin request initiated by JavaScript code by default does not bring any credentials (cookies or HTTP authentication).\u003c/p\u003e\n\u003cp\u003eThat’s uncommon for HTTP-requests. Usually, a request to \u003ca href=\"http://site.com\"\u003ehttp://site.com\u003c/a\u003e is accompanied by all cookies from that domain. Cross-origin requests made by JavaScript methods on the other hand are an exception.\u003c/p\u003e\n\u003cp\u003eFor example, \u003ccode\u003efetch('http://another.com')\u003c/code\u003e does not send any cookies, even those (!) that belong to \u003ccode\u003eanother.com\u003c/code\u003e domain.\u003c/p\u003e\n\u003cp\u003eWhy?\u003c/p\u003e\n\u003cp\u003eThat’s because a request with credentials is much more powerful than without them. If allowed, it grants JavaScript the full power to act on behalf of the user and access sensitive information using their credentials.\u003c/p\u003e\n\u003cp\u003eDoes the server really trust the script that much? Then it must explicitly allow requests with credentials with an additional header.\u003c/p\u003e\n\u003cp\u003eTo send credentials in fetch, we need to add the option credentials: \"include\", like this:\u003c/p\u003e\n\u003cpre class=\"language-javascript\"\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"token function\"\u003efetch\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'http://another.com'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token literal-property property\"\u003ecredentials\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"include\"\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow fetch sends cookies originating from \u003ccode\u003eanother.com\u003c/code\u003e with request to that site.\u003c/p\u003e\n\u003cp\u003eIf the server agrees to accept the request with credentials, it should add a header \u003ccode\u003eAccess-Control-Allow-Credentials: true\u003c/code\u003e to the response, in addition to \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor example:\u003c/p\u003e\n\u003cpre class=\"language-header\"\u003e\u003ccode class=\"language-header\"\u003e200 OK\nAccess-Control-Allow-Origin: https://javascript.info\nAccess-Control-Allow-Credentials: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePlease note: \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e is prohibited from using a star \u003ccode\u003e*\u003c/code\u003e for requests with credentials. Like shown above, it must provide the exact origin there. That’s an additional safety measure, to ensure that the server really knows who it trusts to make such requests.\u003c/p\u003e\n\u003ch4 id=\"why-do-we-need-origin\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#why-do-we-need-origin\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eWhy do we need Origin?\u003c/h4\u003e\n\u003cp\u003eAs you probably know, there’s HTTP-header Referer, that usually contains an url of the page which initiated a network request.\u003c/p\u003e\n\u003cp\u003eFor instance, when fetching \u003ca href=\"http://google.com\"\u003e\u003c/a\u003e from \u003ca href=\"http://javascript.info/some/url\"\u003e\u003c/a\u003e, the headers look like this:\u003c/p\u003e\n\u003cpre class=\"language-header\"\u003e\u003ccode class=\"language-header\"\u003eAccept: */*\nAccept-Charset: utf-8\nAccept-Encoding: gzip,deflate,sdch\nConnection: keep-alive\nHost: google.com\nOrigin: http://javascript.info\nReferer: http://javascript.info/some/url\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, both \u003ccode\u003eReferer\u003c/code\u003e and \u003ccode\u003eOrigin\u003c/code\u003e are present.\u003c/p\u003e\n\u003cp\u003eThe questions:\u003c/p\u003e\n\u003cp\u003eWhy \u003ccode\u003eOrigin\u003c/code\u003e is needed, if \u003ccode\u003eReferer\u003c/code\u003e has even more information?\nIs it possible that there’s no \u003ccode\u003eReferer\u003c/code\u003e or \u003ccode\u003eOrigin\u003c/code\u003e, or is it incorrect?\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eWe need \u003ccode\u003eOrigin\u003c/code\u003e, because sometimes \u003ccode\u003eReferer\u003c/code\u003e is absent. For instance, when we fetch HTTP-page from \u003ccode\u003eHTTPS\u003c/code\u003e (access less secure from more secure), then there’s no \u003ccode\u003eReferer\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ca href=\"/DevNotes/notes/ipudv5n4dfw03m4lfl92zhi\"\u003eContent Security Policy (CSP)\u003c/a\u003e may forbid sending a Referer.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAs we’ll see, fetch has options that prevent sending the Referer and even allow to change it (within the same site).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBy specification, \u003ccode\u003eReferer\u003c/code\u003e is an optional HTTP-header.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eExactly because \u003ccode\u003eReferer\u003c/code\u003e is unreliable, \u003ccode\u003eOrigin\u003c/code\u003e was invented. The browser guarantees correct \u003ccode\u003eOrigin\u003c/code\u003e for cross-origin requests.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","noteIndex":{"id":"root","title":"root","desc":"","updated":1605266684036,"created":1595961348801,"stub":false,"custom":{"stub":false,"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"cf4622cd4e7841f93fb3051e6203c8e6","links":[],"anchors":{},"children":["uRNDWirv66xgHSdrPwMcw","lcTujcWsxBfPEpzP49YbQ","FTV8hEHhyid0DiEvv9gNj","ph4ta0hoi7x0vch4uoz72hn","boufkx25rro7ysodpanan5g","01u0co3RYjOM1bjpc2qIU","xt9womgr90xi5ui5nezev7b","qpngd6ap92mmahr4bh4gc47","hobifg8vvmmg17kt2z5p36a"],"parent":null,"data":{},"body":"\nThis is the root for your Dendron vault.\n\nIf you decide to publish your entire vault, it will be your landing page. You are free to customize any part of this page except the frontmatter at the top, between the `---`. \n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.88.0","enableFullHierarchyNoteTitle":false,"enableHandlebarTemplates":true,"enableSmartRefs":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true,"assetsPrefix":"/DevNotes","copyAssets":true,"siteHierarchies":["root"],"enableSiteLastModified":true,"siteRootDir":"docs","siteUrl":"https://rperez2021.github.io","enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"writeStubs":false,"seo":{"title":"Dendron","description":"Personal knowledge space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enablePrettyLinks":true,"siteFaviconPath":"favicon.ico","siteIndex":"root","enableTaskNotes":true}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"mumqxu4l53t9gax6vz78ptt"},"buildId":"ZngNBAAOWdGj2M_dMvVk6","assetPrefix":"/DevNotes","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>